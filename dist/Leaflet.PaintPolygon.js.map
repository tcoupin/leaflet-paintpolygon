{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./node_modules/@turf/helpers/index.js","webpack:///./node_modules/@turf/invariant/index.js","webpack:///./node_modules/@turf/meta/index.js","webpack:///./node_modules/martinez-polygon-clipping/dist/martinez.js","webpack:///./node_modules/@turf/difference/index.js","webpack:///./node_modules/@turf/union/index.js","webpack:///./node_modules/@turf/circle/index.js","webpack:///./src/myTurf.js","webpack:///./src/PaintPolygon.js","webpack:///./node_modules/style-loader/lib/urls.js","webpack:///./node_modules/style-loader/lib/addStyles.js","webpack:///./src/PaintPolygon.svg","webpack:///./node_modules/css-loader/lib/css-base.js","webpack:///./node_modules/css-loader/lib/url/escape.js","webpack:///./src/PaintPolygon.css","webpack:///./src/PaintPolygon.css?9718","webpack:///./node_modules/@turf/area/index.js","webpack:///./node_modules/@turf/destination/index.js"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","r","value","n","__esModule","object","property","prototype","hasOwnProperty","p","s","feature","geom","properties","options","feat","type","id","bbox","geometry","point","coordinates","polygon","_i","coordinates_1","length","ring","Error","j","lineString","featureCollection","features","fc","multiLineString","multiPoint","multiPolygon","radiansToLength","radians","units","factor","factors","lengthToRadians","distance","radiansToDegrees","Math","PI","isNumber","num","isNaN","Array","isArray","earthRadius","centimeters","centimetres","degrees","feet","inches","kilometers","kilometres","meters","metres","miles","millimeters","millimetres","nauticalmiles","yards","unitsFactors","areaFactors","acres","points","map","coords","polygons","lineStrings","geometryCollection","geometries","round","precision","multiplier","pow","lengthToDegrees","bearingToAzimuth","bearing","angle","degreesToRadians","convertLength","originalUnit","finalUnit","convertArea","area","startFactor","finalFactor","isObject","input","constructor","validateBBox","forEach","validateId","indexOf","radians2degrees","degrees2radians","distanceToDegrees","distanceToRadians","radiansToDistance","bearingToAngle","convertDistance","helpers","getCoord","coord","undefined","getCoords","containsNumber","geojsonType","featureOf","collectionOf","getGeom","geojson","getGeomType","getType","coordEach","callback","excludeWrapCoord","k","stopG","geometryMaybeCollection","isGeometryCollection","wrapShrink","coordIndex","isFeatureCollection","isFeature","stop","featureIndex","geomIndex","multiFeatureIndex","geometryIndex","geomType","propEach","featureEach","geomEach","g","featureProperties","featureBBox","featureId","flattenEach","segmentEach","segmentIndex","previousCoords","previousFeatureIndex","previousMultiIndex","prevGeomIndex","currentCoord","featureIndexCoord","multiPartIndexCoord","currentSegment","lineEach","coordReduce","initialValue","previousValue","propReduce","currentProperties","featureReduce","currentFeature","coordAll","push","geomReduce","currentGeometry","flattenReduce","segmentReduce","started","lineReduce","currentLine","findSegment","findPoint","require","e","t","u","a","f","code","1","martinez","boolean","union","diff","xor","intersection","default","./src/index","2","global","factory","this","print","root","printNode","key","out","row","prefix","isTail","indent","left","right","v","join","height","node","max","DEFAULT_COMPARE","b","rotateLeft","rightNode","parent","balanceFactor","rotateRight","leftNode","AVLTree","comparator","noDuplicates","_comparator","_root","_size","_noDuplicates","prototypeAccessors","size","destroy","contains","cmp","next","successor","prev","predecessor","current","done","pop","keys","values","data","at","index","minNode","maxNode","min","isEmpty","returnValue","remove","find","subtree","compare","insert","newRoot","newNode","pp","load","len","isBalanced","lh","rh","abs","toString","defineProperties","avl","3","TinyQueue","defaultCompare","_down","item","_up","top","peek","pos","halfLength","best","4","signedArea","e1","e2","p1","p2","otherEvent","isBelow","isSubject","specialCases","./signed_area","5","compareEvents","equals","le1","le2","isAbove","contourId","./compare_events","./equals","6","edgeType","operationType","INTERSECTION","UNION","DIFFERENCE","XOR","inResult","event","operation","NORMAL","otherInOut","SAME_TRANSITION","DIFFERENT_TRANSITION","NON_CONTRIBUTING","inOut","isVertical","prevInResult","./edge_type","./operation","7","nextPos","resultEvents","processed","origIndex","newPos","sortedEvents","tmp","sorted","orderEvents","result","contour","isExteriorRing","ringId","initial","resultInOut","8","SweepEvent","se","queue","console","warn","./sweep_event","9","10","11","Queue","operations","processPolygon","contourOrHole","depth","Q","s1","s2","x","y","subject","clipping","sbbox","cbbox","polygonSet","ii","jj","eventQueue","tinyqueue","12","subdivideSegments","connectEdges","fillQueue","EMPTY","trivial","trivialOperation","Infinity","concat","compareBBoxes","./connect_edges","./fill_queue","./subdivide_segments","13","14","divideSegment","se1","se2","inter","nintersections","events","leftCoincide","rightCoincide","./divide_segment","./segment_intersection","15","crossProduct","dotProduct","a1","a2","b1","b2","noEndpointTouch","va","vb","toPoint","kross","sqrKross","sqrLenA","sqrLenB","sqrLenE","sa","sb","smin","smax","16","p0","17","Tree","computeFields","possibleIntersection","compareSegments","begin","sweepLine","rightbound","prevprevEvent","prevEvent","prevprev","./compare_segments","./compute_fields","./possible_intersection","18","EdgeType","clone","copy","_interopDefault","ex","invariant","meta","removeEmptyPolygon","polygon1","polygon2","geom1","geom2","differenced","invariant_1","helpers_1","coords1","coords2","unioned","destination_1","center","radius","steps","myTurf","circle","circle_default","union_default","difference","difference_default","PaintPolygon_PaintPolygon","L","Control","extend","position","minRadius","maxRadius","layerOptions","drawOptions","weight","eraseOptions","color","menu","drawErase","eraseAll","_latlng","_metersPerPixel","onAdd","_map","setRadius","DomUtil","create","_container","_createMenu","onRemove","off","_onMouseMove","_radius","_circle","startDraw","_action","_addMouseListener","circleMarker","addTo","startErase","_removeMouseListener","getLayer","_layer","setData","_data","geoJSON","getData","_iconDraw","_iconErase","DomEvent","on","_clickDraw","_clickErase","_iconSize","_menu","disableClickPropagation","menuContent","cursor","_cursorMove","_clickSize","_iconEraseAll","_clickEraseAll","evt","_resetMenu","_activeIconStyle","hasClass","_closeMenu","_openMenu","removeClass","icon","addClass","target","valueAsNumber","_onMouseDown","_onMouseUp","dragging","disable","_mousedown","enable","_setLatLng","latlng","_stackEvt","getZoom","setLatLng","_latLngAsGeoJSON","lng","lat","_getCircleAsPolygon","zoom","cos","_draw","_erase","action","_stack","_processStack","_processingStack","shift","PaintPolygon","control","paintPolygon","__webpack_exports__","css","location","window","baseUrl","protocol","host","currentDir","pathname","replace","fullMatch","origUrl","newUrl","unquotedOrigUrl","trim","$1","test","JSON","stringify","fn","memo","stylesInDom","isOldIE","document","all","atob","apply","arguments","getElement","styleTarget","querySelector","HTMLIFrameElement","contentDocument","head","singleton","singletonCounter","stylesInsertedAtTop","fixUrls","addStylesToDom","styles","domStyle","refs","parts","addStyle","listToStyles","list","newStyles","base","part","media","sourceMap","insertStyleElement","style","insertInto","lastStyleElementInsertedAtTop","insertAt","nextSibling","insertBefore","appendChild","firstChild","before","removeStyleElement","parentNode","removeChild","idx","splice","createStyleElement","createElement","attrs","addAttrs","el","setAttribute","obj","update","transform","styleIndex","applyToSingletonTag","bind","URL","createObjectURL","revokeObjectURL","Blob","btoa","link","rel","createLinkElement","autoFixUrls","convertToAbsoluteUrls","unescape","encodeURIComponent","blob","oldSrc","href","styleSheet","cssText","createTextNode","newObj","DEBUG","newList","mayRemove","textStore","replaceText","replacement","filter","Boolean","cssNode","childNodes","useSourceMap","content","cssMapping","sourceMapping","sourceURLs","sources","source","sourceRoot","cssWithMappingToString","mediaQuery","alreadyImportedModules","url","slice","escape","hmr","locals","meta_1","RADIUS","polygonArea","total","ringArea","lowerIndex","middleIndex","upperIndex","coordsLength","rad","sin","calculateArea","origin","coordinates1","longitude1","latitude1","bearingRad","latitude2","asin","longitude2","atan2"],"mappings":"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","file":"Leaflet.PaintPolygon.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 7);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * @module helpers\n */\n/**\n * Earth Radius used with the Harvesine formula and approximates using a spherical (non-ellipsoid) Earth.\n *\n * @memberof helpers\n * @type {number}\n */\nexports.earthRadius = 6371008.8;\n/**\n * Unit of measurement factors using a spherical (non-ellipsoid) earth radius.\n *\n * @memberof helpers\n * @type {Object}\n */\nexports.factors = {\n    centimeters: exports.earthRadius * 100,\n    centimetres: exports.earthRadius * 100,\n    degrees: exports.earthRadius / 111325,\n    feet: exports.earthRadius * 3.28084,\n    inches: exports.earthRadius * 39.370,\n    kilometers: exports.earthRadius / 1000,\n    kilometres: exports.earthRadius / 1000,\n    meters: exports.earthRadius,\n    metres: exports.earthRadius,\n    miles: exports.earthRadius / 1609.344,\n    millimeters: exports.earthRadius * 1000,\n    millimetres: exports.earthRadius * 1000,\n    nauticalmiles: exports.earthRadius / 1852,\n    radians: 1,\n    yards: exports.earthRadius / 1.0936,\n};\n/**\n * Units of measurement factors based on 1 meter.\n *\n * @memberof helpers\n * @type {Object}\n */\nexports.unitsFactors = {\n    centimeters: 100,\n    centimetres: 100,\n    degrees: 1 / 111325,\n    feet: 3.28084,\n    inches: 39.370,\n    kilometers: 1 / 1000,\n    kilometres: 1 / 1000,\n    meters: 1,\n    metres: 1,\n    miles: 1 / 1609.344,\n    millimeters: 1000,\n    millimetres: 1000,\n    nauticalmiles: 1 / 1852,\n    radians: 1 / exports.earthRadius,\n    yards: 1 / 1.0936,\n};\n/**\n * Area of measurement factors based on 1 square meter.\n *\n * @memberof helpers\n * @type {Object}\n */\nexports.areaFactors = {\n    acres: 0.000247105,\n    centimeters: 10000,\n    centimetres: 10000,\n    feet: 10.763910417,\n    inches: 1550.003100006,\n    kilometers: 0.000001,\n    kilometres: 0.000001,\n    meters: 1,\n    metres: 1,\n    miles: 3.86e-7,\n    millimeters: 1000000,\n    millimetres: 1000000,\n    yards: 1.195990046,\n};\n/**\n * Wraps a GeoJSON {@link Geometry} in a GeoJSON {@link Feature}.\n *\n * @name feature\n * @param {Geometry} geometry input geometry\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature} a GeoJSON Feature\n * @example\n * var geometry = {\n *   \"type\": \"Point\",\n *   \"coordinates\": [110, 50]\n * };\n *\n * var feature = turf.feature(geometry);\n *\n * //=feature\n */\nfunction feature(geom, properties, options) {\n    if (options === void 0) { options = {}; }\n    var feat = { type: \"Feature\" };\n    if (options.id === 0 || options.id) {\n        feat.id = options.id;\n    }\n    if (options.bbox) {\n        feat.bbox = options.bbox;\n    }\n    feat.properties = properties || {};\n    feat.geometry = geom;\n    return feat;\n}\nexports.feature = feature;\n/**\n * Creates a GeoJSON {@link Geometry} from a Geometry string type & coordinates.\n * For GeometryCollection type use `helpers.geometryCollection`\n *\n * @name geometry\n * @param {string} type Geometry Type\n * @param {Array<any>} coordinates Coordinates\n * @param {Object} [options={}] Optional Parameters\n * @returns {Geometry} a GeoJSON Geometry\n * @example\n * var type = \"Point\";\n * var coordinates = [110, 50];\n * var geometry = turf.geometry(type, coordinates);\n * // => geometry\n */\nfunction geometry(type, coordinates, options) {\n    if (options === void 0) { options = {}; }\n    switch (type) {\n        case \"Point\": return point(coordinates).geometry;\n        case \"LineString\": return lineString(coordinates).geometry;\n        case \"Polygon\": return polygon(coordinates).geometry;\n        case \"MultiPoint\": return multiPoint(coordinates).geometry;\n        case \"MultiLineString\": return multiLineString(coordinates).geometry;\n        case \"MultiPolygon\": return multiPolygon(coordinates).geometry;\n        default: throw new Error(type + \" is invalid\");\n    }\n}\nexports.geometry = geometry;\n/**\n * Creates a {@link Point} {@link Feature} from a Position.\n *\n * @name point\n * @param {Array<number>} coordinates longitude, latitude position (each in decimal degrees)\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<Point>} a Point feature\n * @example\n * var point = turf.point([-75.343, 39.984]);\n *\n * //=point\n */\nfunction point(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    var geom = {\n        type: \"Point\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\nexports.point = point;\n/**\n * Creates a {@link Point} {@link FeatureCollection} from an Array of Point coordinates.\n *\n * @name points\n * @param {Array<Array<number>>} coordinates an array of Points\n * @param {Object} [properties={}] Translate these properties to each Feature\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north]\n * associated with the FeatureCollection\n * @param {string|number} [options.id] Identifier associated with the FeatureCollection\n * @returns {FeatureCollection<Point>} Point Feature\n * @example\n * var points = turf.points([\n *   [-75, 39],\n *   [-80, 45],\n *   [-78, 50]\n * ]);\n *\n * //=points\n */\nfunction points(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    return featureCollection(coordinates.map(function (coords) {\n        return point(coords, properties);\n    }), options);\n}\nexports.points = points;\n/**\n * Creates a {@link Polygon} {@link Feature} from an Array of LinearRings.\n *\n * @name polygon\n * @param {Array<Array<Array<number>>>} coordinates an array of LinearRings\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<Polygon>} Polygon Feature\n * @example\n * var polygon = turf.polygon([[[-5, 52], [-4, 56], [-2, 51], [-7, 54], [-5, 52]]], { name: 'poly1' });\n *\n * //=polygon\n */\nfunction polygon(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    for (var _i = 0, coordinates_1 = coordinates; _i < coordinates_1.length; _i++) {\n        var ring = coordinates_1[_i];\n        if (ring.length < 4) {\n            throw new Error(\"Each LinearRing of a Polygon must have 4 or more Positions.\");\n        }\n        for (var j = 0; j < ring[ring.length - 1].length; j++) {\n            // Check if first point of Polygon contains two numbers\n            if (ring[ring.length - 1][j] !== ring[0][j]) {\n                throw new Error(\"First and last Position are not equivalent.\");\n            }\n        }\n    }\n    var geom = {\n        type: \"Polygon\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\nexports.polygon = polygon;\n/**\n * Creates a {@link Polygon} {@link FeatureCollection} from an Array of Polygon coordinates.\n *\n * @name polygons\n * @param {Array<Array<Array<Array<number>>>>} coordinates an array of Polygon coordinates\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the FeatureCollection\n * @returns {FeatureCollection<Polygon>} Polygon FeatureCollection\n * @example\n * var polygons = turf.polygons([\n *   [[[-5, 52], [-4, 56], [-2, 51], [-7, 54], [-5, 52]]],\n *   [[[-15, 42], [-14, 46], [-12, 41], [-17, 44], [-15, 42]]],\n * ]);\n *\n * //=polygons\n */\nfunction polygons(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    return featureCollection(coordinates.map(function (coords) {\n        return polygon(coords, properties);\n    }), options);\n}\nexports.polygons = polygons;\n/**\n * Creates a {@link LineString} {@link Feature} from an Array of Positions.\n *\n * @name lineString\n * @param {Array<Array<number>>} coordinates an array of Positions\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<LineString>} LineString Feature\n * @example\n * var linestring1 = turf.lineString([[-24, 63], [-23, 60], [-25, 65], [-20, 69]], {name: 'line 1'});\n * var linestring2 = turf.lineString([[-14, 43], [-13, 40], [-15, 45], [-10, 49]], {name: 'line 2'});\n *\n * //=linestring1\n * //=linestring2\n */\nfunction lineString(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    if (coordinates.length < 2) {\n        throw new Error(\"coordinates must be an array of two or more positions\");\n    }\n    var geom = {\n        type: \"LineString\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\nexports.lineString = lineString;\n/**\n * Creates a {@link LineString} {@link FeatureCollection} from an Array of LineString coordinates.\n *\n * @name lineStrings\n * @param {Array<Array<Array<number>>>} coordinates an array of LinearRings\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north]\n * associated with the FeatureCollection\n * @param {string|number} [options.id] Identifier associated with the FeatureCollection\n * @returns {FeatureCollection<LineString>} LineString FeatureCollection\n * @example\n * var linestrings = turf.lineStrings([\n *   [[-24, 63], [-23, 60], [-25, 65], [-20, 69]],\n *   [[-14, 43], [-13, 40], [-15, 45], [-10, 49]]\n * ]);\n *\n * //=linestrings\n */\nfunction lineStrings(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    return featureCollection(coordinates.map(function (coords) {\n        return lineString(coords, properties);\n    }), options);\n}\nexports.lineStrings = lineStrings;\n/**\n * Takes one or more {@link Feature|Features} and creates a {@link FeatureCollection}.\n *\n * @name featureCollection\n * @param {Feature[]} features input features\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {FeatureCollection} FeatureCollection of Features\n * @example\n * var locationA = turf.point([-75.343, 39.984], {name: 'Location A'});\n * var locationB = turf.point([-75.833, 39.284], {name: 'Location B'});\n * var locationC = turf.point([-75.534, 39.123], {name: 'Location C'});\n *\n * var collection = turf.featureCollection([\n *   locationA,\n *   locationB,\n *   locationC\n * ]);\n *\n * //=collection\n */\nfunction featureCollection(features, options) {\n    if (options === void 0) { options = {}; }\n    var fc = { type: \"FeatureCollection\" };\n    if (options.id) {\n        fc.id = options.id;\n    }\n    if (options.bbox) {\n        fc.bbox = options.bbox;\n    }\n    fc.features = features;\n    return fc;\n}\nexports.featureCollection = featureCollection;\n/**\n * Creates a {@link Feature<MultiLineString>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name multiLineString\n * @param {Array<Array<Array<number>>>} coordinates an array of LineStrings\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<MultiLineString>} a MultiLineString feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var multiLine = turf.multiLineString([[[0,0],[10,10]]]);\n *\n * //=multiLine\n */\nfunction multiLineString(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    var geom = {\n        type: \"MultiLineString\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\nexports.multiLineString = multiLineString;\n/**\n * Creates a {@link Feature<MultiPoint>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name multiPoint\n * @param {Array<Array<number>>} coordinates an array of Positions\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<MultiPoint>} a MultiPoint feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var multiPt = turf.multiPoint([[0,0],[10,10]]);\n *\n * //=multiPt\n */\nfunction multiPoint(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    var geom = {\n        type: \"MultiPoint\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\nexports.multiPoint = multiPoint;\n/**\n * Creates a {@link Feature<MultiPolygon>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name multiPolygon\n * @param {Array<Array<Array<Array<number>>>>} coordinates an array of Polygons\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<MultiPolygon>} a multipolygon feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var multiPoly = turf.multiPolygon([[[[0,0],[0,10],[10,10],[10,0],[0,0]]]]);\n *\n * //=multiPoly\n *\n */\nfunction multiPolygon(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    var geom = {\n        type: \"MultiPolygon\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\nexports.multiPolygon = multiPolygon;\n/**\n * Creates a {@link Feature<GeometryCollection>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name geometryCollection\n * @param {Array<Geometry>} geometries an array of GeoJSON Geometries\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<GeometryCollection>} a GeoJSON GeometryCollection Feature\n * @example\n * var pt = turf.geometry(\"Point\", [100, 0]);\n * var line = turf.geometry(\"LineString\", [[101, 0], [102, 1]]);\n * var collection = turf.geometryCollection([pt, line]);\n *\n * // => collection\n */\nfunction geometryCollection(geometries, properties, options) {\n    if (options === void 0) { options = {}; }\n    var geom = {\n        type: \"GeometryCollection\",\n        geometries: geometries,\n    };\n    return feature(geom, properties, options);\n}\nexports.geometryCollection = geometryCollection;\n/**\n * Round number to precision\n *\n * @param {number} num Number\n * @param {number} [precision=0] Precision\n * @returns {number} rounded number\n * @example\n * turf.round(120.4321)\n * //=120\n *\n * turf.round(120.4321, 2)\n * //=120.43\n */\nfunction round(num, precision) {\n    if (precision === void 0) { precision = 0; }\n    if (precision && !(precision >= 0)) {\n        throw new Error(\"precision must be a positive number\");\n    }\n    var multiplier = Math.pow(10, precision || 0);\n    return Math.round(num * multiplier) / multiplier;\n}\nexports.round = round;\n/**\n * Convert a distance measurement (assuming a spherical Earth) from radians to a more friendly unit.\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\n *\n * @name radiansToLength\n * @param {number} radians in radians across the sphere\n * @param {string} [units=\"kilometers\"] can be degrees, radians, miles, or kilometers inches, yards, metres,\n * meters, kilometres, kilometers.\n * @returns {number} distance\n */\nfunction radiansToLength(radians, units) {\n    if (units === void 0) { units = \"kilometers\"; }\n    var factor = exports.factors[units];\n    if (!factor) {\n        throw new Error(units + \" units is invalid\");\n    }\n    return radians * factor;\n}\nexports.radiansToLength = radiansToLength;\n/**\n * Convert a distance measurement (assuming a spherical Earth) from a real-world unit into radians\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\n *\n * @name lengthToRadians\n * @param {number} distance in real units\n * @param {string} [units=\"kilometers\"] can be degrees, radians, miles, or kilometers inches, yards, metres,\n * meters, kilometres, kilometers.\n * @returns {number} radians\n */\nfunction lengthToRadians(distance, units) {\n    if (units === void 0) { units = \"kilometers\"; }\n    var factor = exports.factors[units];\n    if (!factor) {\n        throw new Error(units + \" units is invalid\");\n    }\n    return distance / factor;\n}\nexports.lengthToRadians = lengthToRadians;\n/**\n * Convert a distance measurement (assuming a spherical Earth) from a real-world unit into degrees\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, centimeters, kilometres, feet\n *\n * @name lengthToDegrees\n * @param {number} distance in real units\n * @param {string} [units=\"kilometers\"] can be degrees, radians, miles, or kilometers inches, yards, metres,\n * meters, kilometres, kilometers.\n * @returns {number} degrees\n */\nfunction lengthToDegrees(distance, units) {\n    return radiansToDegrees(lengthToRadians(distance, units));\n}\nexports.lengthToDegrees = lengthToDegrees;\n/**\n * Converts any bearing angle from the north line direction (positive clockwise)\n * and returns an angle between 0-360 degrees (positive clockwise), 0 being the north line\n *\n * @name bearingToAzimuth\n * @param {number} bearing angle, between -180 and +180 degrees\n * @returns {number} angle between 0 and 360 degrees\n */\nfunction bearingToAzimuth(bearing) {\n    var angle = bearing % 360;\n    if (angle < 0) {\n        angle += 360;\n    }\n    return angle;\n}\nexports.bearingToAzimuth = bearingToAzimuth;\n/**\n * Converts an angle in radians to degrees\n *\n * @name radiansToDegrees\n * @param {number} radians angle in radians\n * @returns {number} degrees between 0 and 360 degrees\n */\nfunction radiansToDegrees(radians) {\n    var degrees = radians % (2 * Math.PI);\n    return degrees * 180 / Math.PI;\n}\nexports.radiansToDegrees = radiansToDegrees;\n/**\n * Converts an angle in degrees to radians\n *\n * @name degreesToRadians\n * @param {number} degrees angle between 0 and 360 degrees\n * @returns {number} angle in radians\n */\nfunction degreesToRadians(degrees) {\n    var radians = degrees % 360;\n    return radians * Math.PI / 180;\n}\nexports.degreesToRadians = degreesToRadians;\n/**\n * Converts a length to the requested unit.\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\n *\n * @param {number} length to be converted\n * @param {Units} [originalUnit=\"kilometers\"] of the length\n * @param {Units} [finalUnit=\"kilometers\"] returned unit\n * @returns {number} the converted length\n */\nfunction convertLength(length, originalUnit, finalUnit) {\n    if (originalUnit === void 0) { originalUnit = \"kilometers\"; }\n    if (finalUnit === void 0) { finalUnit = \"kilometers\"; }\n    if (!(length >= 0)) {\n        throw new Error(\"length must be a positive number\");\n    }\n    return radiansToLength(lengthToRadians(length, originalUnit), finalUnit);\n}\nexports.convertLength = convertLength;\n/**\n * Converts a area to the requested unit.\n * Valid units: kilometers, kilometres, meters, metres, centimetres, millimeters, acres, miles, yards, feet, inches\n * @param {number} area to be converted\n * @param {Units} [originalUnit=\"meters\"] of the distance\n * @param {Units} [finalUnit=\"kilometers\"] returned unit\n * @returns {number} the converted distance\n */\nfunction convertArea(area, originalUnit, finalUnit) {\n    if (originalUnit === void 0) { originalUnit = \"meters\"; }\n    if (finalUnit === void 0) { finalUnit = \"kilometers\"; }\n    if (!(area >= 0)) {\n        throw new Error(\"area must be a positive number\");\n    }\n    var startFactor = exports.areaFactors[originalUnit];\n    if (!startFactor) {\n        throw new Error(\"invalid original units\");\n    }\n    var finalFactor = exports.areaFactors[finalUnit];\n    if (!finalFactor) {\n        throw new Error(\"invalid final units\");\n    }\n    return (area / startFactor) * finalFactor;\n}\nexports.convertArea = convertArea;\n/**\n * isNumber\n *\n * @param {*} num Number to validate\n * @returns {boolean} true/false\n * @example\n * turf.isNumber(123)\n * //=true\n * turf.isNumber('foo')\n * //=false\n */\nfunction isNumber(num) {\n    return !isNaN(num) && num !== null && !Array.isArray(num);\n}\nexports.isNumber = isNumber;\n/**\n * isObject\n *\n * @param {*} input variable to validate\n * @returns {boolean} true/false\n * @example\n * turf.isObject({elevation: 10})\n * //=true\n * turf.isObject('foo')\n * //=false\n */\nfunction isObject(input) {\n    return (!!input) && (input.constructor === Object);\n}\nexports.isObject = isObject;\n/**\n * Validate BBox\n *\n * @private\n * @param {Array<number>} bbox BBox to validate\n * @returns {void}\n * @throws Error if BBox is not valid\n * @example\n * validateBBox([-180, -40, 110, 50])\n * //=OK\n * validateBBox([-180, -40])\n * //=Error\n * validateBBox('Foo')\n * //=Error\n * validateBBox(5)\n * //=Error\n * validateBBox(null)\n * //=Error\n * validateBBox(undefined)\n * //=Error\n */\nfunction validateBBox(bbox) {\n    if (!bbox) {\n        throw new Error(\"bbox is required\");\n    }\n    if (!Array.isArray(bbox)) {\n        throw new Error(\"bbox must be an Array\");\n    }\n    if (bbox.length !== 4 && bbox.length !== 6) {\n        throw new Error(\"bbox must be an Array of 4 or 6 numbers\");\n    }\n    bbox.forEach(function (num) {\n        if (!isNumber(num)) {\n            throw new Error(\"bbox must only contain numbers\");\n        }\n    });\n}\nexports.validateBBox = validateBBox;\n/**\n * Validate Id\n *\n * @private\n * @param {string|number} id Id to validate\n * @returns {void}\n * @throws Error if Id is not valid\n * @example\n * validateId([-180, -40, 110, 50])\n * //=Error\n * validateId([-180, -40])\n * //=Error\n * validateId('Foo')\n * //=OK\n * validateId(5)\n * //=OK\n * validateId(null)\n * //=Error\n * validateId(undefined)\n * //=Error\n */\nfunction validateId(id) {\n    if (!id) {\n        throw new Error(\"id is required\");\n    }\n    if ([\"string\", \"number\"].indexOf(typeof id) === -1) {\n        throw new Error(\"id must be a number or a string\");\n    }\n}\nexports.validateId = validateId;\n// Deprecated methods\nfunction radians2degrees() {\n    throw new Error(\"method has been renamed to `radiansToDegrees`\");\n}\nexports.radians2degrees = radians2degrees;\nfunction degrees2radians() {\n    throw new Error(\"method has been renamed to `degreesToRadians`\");\n}\nexports.degrees2radians = degrees2radians;\nfunction distanceToDegrees() {\n    throw new Error(\"method has been renamed to `lengthToDegrees`\");\n}\nexports.distanceToDegrees = distanceToDegrees;\nfunction distanceToRadians() {\n    throw new Error(\"method has been renamed to `lengthToRadians`\");\n}\nexports.distanceToRadians = distanceToRadians;\nfunction radiansToDistance() {\n    throw new Error(\"method has been renamed to `radiansToLength`\");\n}\nexports.radiansToDistance = radiansToDistance;\nfunction bearingToAngle() {\n    throw new Error(\"method has been renamed to `bearingToAzimuth`\");\n}\nexports.bearingToAngle = bearingToAngle;\nfunction convertDistance() {\n    throw new Error(\"method has been renamed to `convertLength`\");\n}\nexports.convertDistance = convertDistance;\n","'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nvar helpers = require('@turf/helpers');\n\n/**\n * Unwrap a coordinate from a Point Feature, Geometry or a single coordinate.\n *\n * @name getCoord\n * @param {Array<number>|Geometry<Point>|Feature<Point>} coord GeoJSON Point or an Array of numbers\n * @returns {Array<number>} coordinates\n * @example\n * var pt = turf.point([10, 10]);\n *\n * var coord = turf.getCoord(pt);\n * //= [10, 10]\n */\nfunction getCoord(coord) {\n    if (!coord) throw new Error('coord is required');\n    if (coord.type === 'Feature' && coord.geometry !== null && coord.geometry.type === 'Point') return coord.geometry.coordinates;\n    if (coord.type === 'Point') return coord.coordinates;\n    if (Array.isArray(coord) && coord.length >= 2 && coord[0].length === undefined && coord[1].length === undefined) return coord;\n\n    throw new Error('coord must be GeoJSON Point or an Array of numbers');\n}\n\n/**\n * Unwrap coordinates from a Feature, Geometry Object or an Array\n *\n * @name getCoords\n * @param {Array<any>|Geometry|Feature} coords Feature, Geometry Object or an Array\n * @returns {Array<any>} coordinates\n * @example\n * var poly = turf.polygon([[[119.32, -8.7], [119.55, -8.69], [119.51, -8.54], [119.32, -8.7]]]);\n *\n * var coords = turf.getCoords(poly);\n * //= [[[119.32, -8.7], [119.55, -8.69], [119.51, -8.54], [119.32, -8.7]]]\n */\nfunction getCoords(coords) {\n    if (!coords) throw new Error('coords is required');\n\n    // Feature\n    if (coords.type === 'Feature' && coords.geometry !== null) return coords.geometry.coordinates;\n\n    // Geometry\n    if (coords.coordinates) return coords.coordinates;\n\n    // Array of numbers\n    if (Array.isArray(coords)) return coords;\n\n    throw new Error('coords must be GeoJSON Feature, Geometry Object or an Array');\n}\n\n/**\n * Checks if coordinates contains a number\n *\n * @name containsNumber\n * @param {Array<any>} coordinates GeoJSON Coordinates\n * @returns {boolean} true if Array contains a number\n */\nfunction containsNumber(coordinates) {\n    if (coordinates.length > 1 && helpers.isNumber(coordinates[0]) && helpers.isNumber(coordinates[1])) {\n        return true;\n    }\n\n    if (Array.isArray(coordinates[0]) && coordinates[0].length) {\n        return containsNumber(coordinates[0]);\n    }\n    throw new Error('coordinates must only contain numbers');\n}\n\n/**\n * Enforce expectations about types of GeoJSON objects for Turf.\n *\n * @name geojsonType\n * @param {GeoJSON} value any GeoJSON object\n * @param {string} type expected GeoJSON type\n * @param {string} name name of calling function\n * @throws {Error} if value is not the expected type.\n */\nfunction geojsonType(value, type, name) {\n    if (!type || !name) throw new Error('type and name required');\n\n    if (!value || value.type !== type) {\n        throw new Error('Invalid input to ' + name + ': must be a ' + type + ', given ' + value.type);\n    }\n}\n\n/**\n * Enforce expectations about types of {@link Feature} inputs for Turf.\n * Internally this uses {@link geojsonType} to judge geometry types.\n *\n * @name featureOf\n * @param {Feature} feature a feature with an expected geometry type\n * @param {string} type expected GeoJSON type\n * @param {string} name name of calling function\n * @throws {Error} error if value is not the expected type.\n */\nfunction featureOf(feature, type, name) {\n    if (!feature) throw new Error('No feature passed');\n    if (!name) throw new Error('.featureOf() requires a name');\n    if (!feature || feature.type !== 'Feature' || !feature.geometry) {\n        throw new Error('Invalid input to ' + name + ', Feature with geometry required');\n    }\n    if (!feature.geometry || feature.geometry.type !== type) {\n        throw new Error('Invalid input to ' + name + ': must be a ' + type + ', given ' + feature.geometry.type);\n    }\n}\n\n/**\n * Enforce expectations about types of {@link FeatureCollection} inputs for Turf.\n * Internally this uses {@link geojsonType} to judge geometry types.\n *\n * @name collectionOf\n * @param {FeatureCollection} featureCollection a FeatureCollection for which features will be judged\n * @param {string} type expected GeoJSON type\n * @param {string} name name of calling function\n * @throws {Error} if value is not the expected type.\n */\nfunction collectionOf(featureCollection, type, name) {\n    if (!featureCollection) throw new Error('No featureCollection passed');\n    if (!name) throw new Error('.collectionOf() requires a name');\n    if (!featureCollection || featureCollection.type !== 'FeatureCollection') {\n        throw new Error('Invalid input to ' + name + ', FeatureCollection required');\n    }\n    for (var i = 0; i < featureCollection.features.length; i++) {\n        var feature = featureCollection.features[i];\n        if (!feature || feature.type !== 'Feature' || !feature.geometry) {\n            throw new Error('Invalid input to ' + name + ', Feature with geometry required');\n        }\n        if (!feature.geometry || feature.geometry.type !== type) {\n            throw new Error('Invalid input to ' + name + ': must be a ' + type + ', given ' + feature.geometry.type);\n        }\n    }\n}\n\n/**\n * Get Geometry from Feature or Geometry Object\n *\n * @param {Feature|Geometry} geojson GeoJSON Feature or Geometry Object\n * @returns {Geometry|null} GeoJSON Geometry Object\n * @throws {Error} if geojson is not a Feature or Geometry Object\n * @example\n * var point = {\n *   \"type\": \"Feature\",\n *   \"properties\": {},\n *   \"geometry\": {\n *     \"type\": \"Point\",\n *     \"coordinates\": [110, 40]\n *   }\n * }\n * var geom = turf.getGeom(point)\n * //={\"type\": \"Point\", \"coordinates\": [110, 40]}\n */\nfunction getGeom(geojson) {\n    if (!geojson) throw new Error('geojson is required');\n    if (geojson.geometry !== undefined) return geojson.geometry;\n    if (geojson.coordinates || geojson.geometries) return geojson;\n    throw new Error('geojson must be a valid Feature or Geometry Object');\n}\n\n/**\n * Get Geometry Type from Feature or Geometry Object\n *\n * @throws {Error} **DEPRECATED** in v5.0.0 in favor of getType\n */\nfunction getGeomType() {\n    throw new Error('invariant.getGeomType has been deprecated in v5.0 in favor of invariant.getType');\n}\n\n/**\n * Get GeoJSON object's type, Geometry type is prioritize.\n *\n * @param {GeoJSON} geojson GeoJSON object\n * @param {string} [name=\"geojson\"] name of the variable to display in error message\n * @returns {string} GeoJSON type\n * @example\n * var point = {\n *   \"type\": \"Feature\",\n *   \"properties\": {},\n *   \"geometry\": {\n *     \"type\": \"Point\",\n *     \"coordinates\": [110, 40]\n *   }\n * }\n * var geom = turf.getType(point)\n * //=\"Point\"\n */\nfunction getType(geojson, name) {\n    if (!geojson) throw new Error((name || 'geojson') + ' is required');\n    // GeoJSON Feature & GeometryCollection\n    if (geojson.geometry && geojson.geometry.type) return geojson.geometry.type;\n    // GeoJSON Geometry & FeatureCollection\n    if (geojson.type) return geojson.type;\n    throw new Error((name || 'geojson') + ' is invalid');\n}\n\nexports.getCoord = getCoord;\nexports.getCoords = getCoords;\nexports.containsNumber = containsNumber;\nexports.geojsonType = geojsonType;\nexports.featureOf = featureOf;\nexports.collectionOf = collectionOf;\nexports.getGeom = getGeom;\nexports.getGeomType = getGeomType;\nexports.getType = getType;\n","'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nvar helpers = require('@turf/helpers');\n\n/**\n * Callback for coordEach\n *\n * @callback coordEachCallback\n * @param {Array<number>} currentCoord The current coordinate being processed.\n * @param {number} coordIndex The current index of the coordinate being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n * @param {number} geometryIndex The current index of the Geometry being processed.\n */\n\n/**\n * Iterate over coordinates in any GeoJSON object, similar to Array.forEach()\n *\n * @name coordEach\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentCoord, coordIndex, featureIndex, multiFeatureIndex)\n * @param {boolean} [excludeWrapCoord=false] whether or not to include the final coordinate of LinearRings that wraps the ring in its iteration.\n * @returns {void}\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {\"foo\": \"bar\"}),\n *   turf.point([36, 53], {\"hello\": \"world\"})\n * ]);\n *\n * turf.coordEach(features, function (currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {\n *   //=currentCoord\n *   //=coordIndex\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n * });\n */\nfunction coordEach(geojson, callback, excludeWrapCoord) {\n    // Handles null Geometry -- Skips this GeoJSON\n    if (geojson === null) return;\n    var j, k, l, geometry, stopG, coords,\n        geometryMaybeCollection,\n        wrapShrink = 0,\n        coordIndex = 0,\n        isGeometryCollection,\n        type = geojson.type,\n        isFeatureCollection = type === 'FeatureCollection',\n        isFeature = type === 'Feature',\n        stop = isFeatureCollection ? geojson.features.length : 1;\n\n    // This logic may look a little weird. The reason why it is that way\n    // is because it's trying to be fast. GeoJSON supports multiple kinds\n    // of objects at its root: FeatureCollection, Features, Geometries.\n    // This function has the responsibility of handling all of them, and that\n    // means that some of the `for` loops you see below actually just don't apply\n    // to certain inputs. For instance, if you give this just a\n    // Point geometry, then both loops are short-circuited and all we do\n    // is gradually rename the input until it's called 'geometry'.\n    //\n    // This also aims to allocate as few resources as possible: just a\n    // few numbers and booleans, rather than any temporary arrays as would\n    // be required with the normalization approach.\n    for (var featureIndex = 0; featureIndex < stop; featureIndex++) {\n        geometryMaybeCollection = (isFeatureCollection ? geojson.features[featureIndex].geometry :\n            (isFeature ? geojson.geometry : geojson));\n        isGeometryCollection = (geometryMaybeCollection) ? geometryMaybeCollection.type === 'GeometryCollection' : false;\n        stopG = isGeometryCollection ? geometryMaybeCollection.geometries.length : 1;\n\n        for (var geomIndex = 0; geomIndex < stopG; geomIndex++) {\n            var multiFeatureIndex = 0;\n            var geometryIndex = 0;\n            geometry = isGeometryCollection ?\n                geometryMaybeCollection.geometries[geomIndex] : geometryMaybeCollection;\n\n            // Handles null Geometry -- Skips this geometry\n            if (geometry === null) continue;\n            coords = geometry.coordinates;\n            var geomType = geometry.type;\n\n            wrapShrink = (excludeWrapCoord && (geomType === 'Polygon' || geomType === 'MultiPolygon')) ? 1 : 0;\n\n            switch (geomType) {\n            case null:\n                break;\n            case 'Point':\n                if (callback(coords, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) === false) return false;\n                coordIndex++;\n                multiFeatureIndex++;\n                break;\n            case 'LineString':\n            case 'MultiPoint':\n                for (j = 0; j < coords.length; j++) {\n                    if (callback(coords[j], coordIndex, featureIndex, multiFeatureIndex, geometryIndex) === false) return false;\n                    coordIndex++;\n                    if (geomType === 'MultiPoint') multiFeatureIndex++;\n                }\n                if (geomType === 'LineString') multiFeatureIndex++;\n                break;\n            case 'Polygon':\n            case 'MultiLineString':\n                for (j = 0; j < coords.length; j++) {\n                    for (k = 0; k < coords[j].length - wrapShrink; k++) {\n                        if (callback(coords[j][k], coordIndex, featureIndex, multiFeatureIndex, geometryIndex) === false) return false;\n                        coordIndex++;\n                    }\n                    if (geomType === 'MultiLineString') multiFeatureIndex++;\n                    if (geomType === 'Polygon') geometryIndex++;\n                }\n                if (geomType === 'Polygon') multiFeatureIndex++;\n                break;\n            case 'MultiPolygon':\n                for (j = 0; j < coords.length; j++) {\n                    geometryIndex = 0;\n                    for (k = 0; k < coords[j].length; k++) {\n                        for (l = 0; l < coords[j][k].length - wrapShrink; l++) {\n                            if (callback(coords[j][k][l], coordIndex, featureIndex, multiFeatureIndex, geometryIndex) === false) return false;\n                            coordIndex++;\n                        }\n                        geometryIndex++;\n                    }\n                    multiFeatureIndex++;\n                }\n                break;\n            case 'GeometryCollection':\n                for (j = 0; j < geometry.geometries.length; j++)\n                    if (coordEach(geometry.geometries[j], callback, excludeWrapCoord) === false) return false;\n                break;\n            default:\n                throw new Error('Unknown Geometry Type');\n            }\n        }\n    }\n}\n\n/**\n * Callback for coordReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback coordReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Array<number>} currentCoord The current coordinate being processed.\n * @param {number} coordIndex The current index of the coordinate being processed.\n * Starts at index 0, if an initialValue is provided, and at index 1 otherwise.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n * @param {number} geometryIndex The current index of the Geometry being processed.\n */\n\n/**\n * Reduce coordinates in any GeoJSON object, similar to Array.reduce()\n *\n * @name coordReduce\n * @param {FeatureCollection|Geometry|Feature} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentCoord, coordIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @param {boolean} [excludeWrapCoord=false] whether or not to include the final coordinate of LinearRings that wraps the ring in its iteration.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {\"foo\": \"bar\"}),\n *   turf.point([36, 53], {\"hello\": \"world\"})\n * ]);\n *\n * turf.coordReduce(features, function (previousValue, currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {\n *   //=previousValue\n *   //=currentCoord\n *   //=coordIndex\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n *   return currentCoord;\n * });\n */\nfunction coordReduce(geojson, callback, initialValue, excludeWrapCoord) {\n    var previousValue = initialValue;\n    coordEach(geojson, function (currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {\n        if (coordIndex === 0 && initialValue === undefined) previousValue = currentCoord;\n        else previousValue = callback(previousValue, currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex);\n    }, excludeWrapCoord);\n    return previousValue;\n}\n\n/**\n * Callback for propEach\n *\n * @callback propEachCallback\n * @param {Object} currentProperties The current Properties being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n */\n\n/**\n * Iterate over properties in any GeoJSON object, similar to Array.forEach()\n *\n * @name propEach\n * @param {FeatureCollection|Feature} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentProperties, featureIndex)\n * @returns {void}\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.propEach(features, function (currentProperties, featureIndex) {\n *   //=currentProperties\n *   //=featureIndex\n * });\n */\nfunction propEach(geojson, callback) {\n    var i;\n    switch (geojson.type) {\n    case 'FeatureCollection':\n        for (i = 0; i < geojson.features.length; i++) {\n            if (callback(geojson.features[i].properties, i) === false) break;\n        }\n        break;\n    case 'Feature':\n        callback(geojson.properties, 0);\n        break;\n    }\n}\n\n\n/**\n * Callback for propReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback propReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {*} currentProperties The current Properties being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n */\n\n/**\n * Reduce properties in any GeoJSON object into a single value,\n * similar to how Array.reduce works. However, in this case we lazily run\n * the reduction, so an array of all properties is unnecessary.\n *\n * @name propReduce\n * @param {FeatureCollection|Feature} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentProperties, featureIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.propReduce(features, function (previousValue, currentProperties, featureIndex) {\n *   //=previousValue\n *   //=currentProperties\n *   //=featureIndex\n *   return currentProperties\n * });\n */\nfunction propReduce(geojson, callback, initialValue) {\n    var previousValue = initialValue;\n    propEach(geojson, function (currentProperties, featureIndex) {\n        if (featureIndex === 0 && initialValue === undefined) previousValue = currentProperties;\n        else previousValue = callback(previousValue, currentProperties, featureIndex);\n    });\n    return previousValue;\n}\n\n/**\n * Callback for featureEach\n *\n * @callback featureEachCallback\n * @param {Feature<any>} currentFeature The current Feature being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n */\n\n/**\n * Iterate over features in any GeoJSON object, similar to\n * Array.forEach.\n *\n * @name featureEach\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentFeature, featureIndex)\n * @returns {void}\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {foo: 'bar'}),\n *   turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.featureEach(features, function (currentFeature, featureIndex) {\n *   //=currentFeature\n *   //=featureIndex\n * });\n */\nfunction featureEach(geojson, callback) {\n    if (geojson.type === 'Feature') {\n        callback(geojson, 0);\n    } else if (geojson.type === 'FeatureCollection') {\n        for (var i = 0; i < geojson.features.length; i++) {\n            if (callback(geojson.features[i], i) === false) break;\n        }\n    }\n}\n\n/**\n * Callback for featureReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback featureReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature} currentFeature The current Feature being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n */\n\n/**\n * Reduce features in any GeoJSON object, similar to Array.reduce().\n *\n * @name featureReduce\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentFeature, featureIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {\"foo\": \"bar\"}),\n *   turf.point([36, 53], {\"hello\": \"world\"})\n * ]);\n *\n * turf.featureReduce(features, function (previousValue, currentFeature, featureIndex) {\n *   //=previousValue\n *   //=currentFeature\n *   //=featureIndex\n *   return currentFeature\n * });\n */\nfunction featureReduce(geojson, callback, initialValue) {\n    var previousValue = initialValue;\n    featureEach(geojson, function (currentFeature, featureIndex) {\n        if (featureIndex === 0 && initialValue === undefined) previousValue = currentFeature;\n        else previousValue = callback(previousValue, currentFeature, featureIndex);\n    });\n    return previousValue;\n}\n\n/**\n * Get all coordinates from any GeoJSON object.\n *\n * @name coordAll\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @returns {Array<Array<number>>} coordinate position array\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {foo: 'bar'}),\n *   turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * var coords = turf.coordAll(features);\n * //= [[26, 37], [36, 53]]\n */\nfunction coordAll(geojson) {\n    var coords = [];\n    coordEach(geojson, function (coord) {\n        coords.push(coord);\n    });\n    return coords;\n}\n\n/**\n * Callback for geomEach\n *\n * @callback geomEachCallback\n * @param {Geometry} currentGeometry The current Geometry being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {Object} featureProperties The current Feature Properties being processed.\n * @param {Array<number>} featureBBox The current Feature BBox being processed.\n * @param {number|string} featureId The current Feature Id being processed.\n */\n\n/**\n * Iterate over each geometry in any GeoJSON object, similar to Array.forEach()\n *\n * @name geomEach\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentGeometry, featureIndex, featureProperties, featureBBox, featureId)\n * @returns {void}\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.geomEach(features, function (currentGeometry, featureIndex, featureProperties, featureBBox, featureId) {\n *   //=currentGeometry\n *   //=featureIndex\n *   //=featureProperties\n *   //=featureBBox\n *   //=featureId\n * });\n */\nfunction geomEach(geojson, callback) {\n    var i, j, g, geometry, stopG,\n        geometryMaybeCollection,\n        isGeometryCollection,\n        featureProperties,\n        featureBBox,\n        featureId,\n        featureIndex = 0,\n        isFeatureCollection = geojson.type === 'FeatureCollection',\n        isFeature = geojson.type === 'Feature',\n        stop = isFeatureCollection ? geojson.features.length : 1;\n\n    // This logic may look a little weird. The reason why it is that way\n    // is because it's trying to be fast. GeoJSON supports multiple kinds\n    // of objects at its root: FeatureCollection, Features, Geometries.\n    // This function has the responsibility of handling all of them, and that\n    // means that some of the `for` loops you see below actually just don't apply\n    // to certain inputs. For instance, if you give this just a\n    // Point geometry, then both loops are short-circuited and all we do\n    // is gradually rename the input until it's called 'geometry'.\n    //\n    // This also aims to allocate as few resources as possible: just a\n    // few numbers and booleans, rather than any temporary arrays as would\n    // be required with the normalization approach.\n    for (i = 0; i < stop; i++) {\n\n        geometryMaybeCollection = (isFeatureCollection ? geojson.features[i].geometry :\n            (isFeature ? geojson.geometry : geojson));\n        featureProperties = (isFeatureCollection ? geojson.features[i].properties :\n            (isFeature ? geojson.properties : {}));\n        featureBBox = (isFeatureCollection ? geojson.features[i].bbox :\n            (isFeature ? geojson.bbox : undefined));\n        featureId = (isFeatureCollection ? geojson.features[i].id :\n            (isFeature ? geojson.id : undefined));\n        isGeometryCollection = (geometryMaybeCollection) ? geometryMaybeCollection.type === 'GeometryCollection' : false;\n        stopG = isGeometryCollection ? geometryMaybeCollection.geometries.length : 1;\n\n        for (g = 0; g < stopG; g++) {\n            geometry = isGeometryCollection ?\n                geometryMaybeCollection.geometries[g] : geometryMaybeCollection;\n\n            // Handle null Geometry\n            if (geometry === null) {\n                if (callback(null, featureIndex, featureProperties, featureBBox, featureId) === false) return false;\n                continue;\n            }\n            switch (geometry.type) {\n            case 'Point':\n            case 'LineString':\n            case 'MultiPoint':\n            case 'Polygon':\n            case 'MultiLineString':\n            case 'MultiPolygon': {\n                if (callback(geometry, featureIndex, featureProperties, featureBBox, featureId) === false) return false;\n                break;\n            }\n            case 'GeometryCollection': {\n                for (j = 0; j < geometry.geometries.length; j++) {\n                    if (callback(geometry.geometries[j], featureIndex, featureProperties, featureBBox, featureId) === false) return false;\n                }\n                break;\n            }\n            default:\n                throw new Error('Unknown Geometry Type');\n            }\n        }\n        // Only increase `featureIndex` per each feature\n        featureIndex++;\n    }\n}\n\n/**\n * Callback for geomReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback geomReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Geometry} currentGeometry The current Geometry being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {Object} featureProperties The current Feature Properties being processed.\n * @param {Array<number>} featureBBox The current Feature BBox being processed.\n * @param {number|string} featureId The current Feature Id being processed.\n */\n\n/**\n * Reduce geometry in any GeoJSON object, similar to Array.reduce().\n *\n * @name geomReduce\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentGeometry, featureIndex, featureProperties, featureBBox, featureId)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.geomReduce(features, function (previousValue, currentGeometry, featureIndex, featureProperties, featureBBox, featureId) {\n *   //=previousValue\n *   //=currentGeometry\n *   //=featureIndex\n *   //=featureProperties\n *   //=featureBBox\n *   //=featureId\n *   return currentGeometry\n * });\n */\nfunction geomReduce(geojson, callback, initialValue) {\n    var previousValue = initialValue;\n    geomEach(geojson, function (currentGeometry, featureIndex, featureProperties, featureBBox, featureId) {\n        if (featureIndex === 0 && initialValue === undefined) previousValue = currentGeometry;\n        else previousValue = callback(previousValue, currentGeometry, featureIndex, featureProperties, featureBBox, featureId);\n    });\n    return previousValue;\n}\n\n/**\n * Callback for flattenEach\n *\n * @callback flattenEachCallback\n * @param {Feature} currentFeature The current flattened feature being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n */\n\n/**\n * Iterate over flattened features in any GeoJSON object, similar to\n * Array.forEach.\n *\n * @name flattenEach\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentFeature, featureIndex, multiFeatureIndex)\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.multiPoint([[40, 30], [36, 53]], {hello: 'world'})\n * ]);\n *\n * turf.flattenEach(features, function (currentFeature, featureIndex, multiFeatureIndex) {\n *   //=currentFeature\n *   //=featureIndex\n *   //=multiFeatureIndex\n * });\n */\nfunction flattenEach(geojson, callback) {\n    geomEach(geojson, function (geometry, featureIndex, properties, bbox, id) {\n        // Callback for single geometry\n        var type = (geometry === null) ? null : geometry.type;\n        switch (type) {\n        case null:\n        case 'Point':\n        case 'LineString':\n        case 'Polygon':\n            if (callback(helpers.feature(geometry, properties, {bbox: bbox, id: id}), featureIndex, 0) === false) return false;\n            return;\n        }\n\n        var geomType;\n\n        // Callback for multi-geometry\n        switch (type) {\n        case 'MultiPoint':\n            geomType = 'Point';\n            break;\n        case 'MultiLineString':\n            geomType = 'LineString';\n            break;\n        case 'MultiPolygon':\n            geomType = 'Polygon';\n            break;\n        }\n\n        for (var multiFeatureIndex = 0; multiFeatureIndex < geometry.coordinates.length; multiFeatureIndex++) {\n            var coordinate = geometry.coordinates[multiFeatureIndex];\n            var geom = {\n                type: geomType,\n                coordinates: coordinate\n            };\n            if (callback(helpers.feature(geom, properties), featureIndex, multiFeatureIndex) === false) return false;\n        }\n    });\n}\n\n/**\n * Callback for flattenReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback flattenReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature} currentFeature The current Feature being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n */\n\n/**\n * Reduce flattened features in any GeoJSON object, similar to Array.reduce().\n *\n * @name flattenReduce\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentFeature, featureIndex, multiFeatureIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.multiPoint([[40, 30], [36, 53]], {hello: 'world'})\n * ]);\n *\n * turf.flattenReduce(features, function (previousValue, currentFeature, featureIndex, multiFeatureIndex) {\n *   //=previousValue\n *   //=currentFeature\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   return currentFeature\n * });\n */\nfunction flattenReduce(geojson, callback, initialValue) {\n    var previousValue = initialValue;\n    flattenEach(geojson, function (currentFeature, featureIndex, multiFeatureIndex) {\n        if (featureIndex === 0 && multiFeatureIndex === 0 && initialValue === undefined) previousValue = currentFeature;\n        else previousValue = callback(previousValue, currentFeature, featureIndex, multiFeatureIndex);\n    });\n    return previousValue;\n}\n\n/**\n * Callback for segmentEach\n *\n * @callback segmentEachCallback\n * @param {Feature<LineString>} currentSegment The current Segment being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n * @param {number} geometryIndex The current index of the Geometry being processed.\n * @param {number} segmentIndex The current index of the Segment being processed.\n * @returns {void}\n */\n\n/**\n * Iterate over 2-vertex line segment in any GeoJSON object, similar to Array.forEach()\n * (Multi)Point geometries do not contain segments therefore they are ignored during this operation.\n *\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON\n * @param {Function} callback a method that takes (currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex)\n * @returns {void}\n * @example\n * var polygon = turf.polygon([[[-50, 5], [-40, -10], [-50, -10], [-40, 5], [-50, 5]]]);\n *\n * // Iterate over GeoJSON by 2-vertex segments\n * turf.segmentEach(polygon, function (currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) {\n *   //=currentSegment\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n *   //=segmentIndex\n * });\n *\n * // Calculate the total number of segments\n * var total = 0;\n * turf.segmentEach(polygon, function () {\n *     total++;\n * });\n */\nfunction segmentEach(geojson, callback) {\n    flattenEach(geojson, function (feature, featureIndex, multiFeatureIndex) {\n        var segmentIndex = 0;\n\n        // Exclude null Geometries\n        if (!feature.geometry) return;\n        // (Multi)Point geometries do not contain segments therefore they are ignored during this operation.\n        var type = feature.geometry.type;\n        if (type === 'Point' || type === 'MultiPoint') return;\n\n        // Generate 2-vertex line segments\n        var previousCoords;\n        var previousFeatureIndex = 0;\n        var previousMultiIndex = 0;\n        var prevGeomIndex = 0;\n        if (coordEach(feature, function (currentCoord, coordIndex, featureIndexCoord, multiPartIndexCoord, geometryIndex) {\n            // Simulating a meta.coordReduce() since `reduce` operations cannot be stopped by returning `false`\n            if (previousCoords === undefined || featureIndex > previousFeatureIndex || multiPartIndexCoord > previousMultiIndex || geometryIndex > prevGeomIndex) {\n                previousCoords = currentCoord;\n                previousFeatureIndex = featureIndex;\n                previousMultiIndex = multiPartIndexCoord;\n                prevGeomIndex = geometryIndex;\n                segmentIndex = 0;\n                return;\n            }\n            var currentSegment = helpers.lineString([previousCoords, currentCoord], feature.properties);\n            if (callback(currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) === false) return false;\n            segmentIndex++;\n            previousCoords = currentCoord;\n        }) === false) return false;\n    });\n}\n\n/**\n * Callback for segmentReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback segmentReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature<LineString>} currentSegment The current Segment being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n * @param {number} geometryIndex The current index of the Geometry being processed.\n * @param {number} segmentIndex The current index of the Segment being processed.\n */\n\n/**\n * Reduce 2-vertex line segment in any GeoJSON object, similar to Array.reduce()\n * (Multi)Point geometries do not contain segments therefore they are ignored during this operation.\n *\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON\n * @param {Function} callback a method that takes (previousValue, currentSegment, currentIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {void}\n * @example\n * var polygon = turf.polygon([[[-50, 5], [-40, -10], [-50, -10], [-40, 5], [-50, 5]]]);\n *\n * // Iterate over GeoJSON by 2-vertex segments\n * turf.segmentReduce(polygon, function (previousSegment, currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) {\n *   //= previousSegment\n *   //= currentSegment\n *   //= featureIndex\n *   //= multiFeatureIndex\n *   //= geometryIndex\n *   //= segmentInex\n *   return currentSegment\n * });\n *\n * // Calculate the total number of segments\n * var initialValue = 0\n * var total = turf.segmentReduce(polygon, function (previousValue) {\n *     previousValue++;\n *     return previousValue;\n * }, initialValue);\n */\nfunction segmentReduce(geojson, callback, initialValue) {\n    var previousValue = initialValue;\n    var started = false;\n    segmentEach(geojson, function (currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) {\n        if (started === false && initialValue === undefined) previousValue = currentSegment;\n        else previousValue = callback(previousValue, currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex);\n        started = true;\n    });\n    return previousValue;\n}\n\n/**\n * Callback for lineEach\n *\n * @callback lineEachCallback\n * @param {Feature<LineString>} currentLine The current LineString|LinearRing being processed\n * @param {number} featureIndex The current index of the Feature being processed\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed\n * @param {number} geometryIndex The current index of the Geometry being processed\n */\n\n/**\n * Iterate over line or ring coordinates in LineString, Polygon, MultiLineString, MultiPolygon Features or Geometries,\n * similar to Array.forEach.\n *\n * @name lineEach\n * @param {Geometry|Feature<LineString|Polygon|MultiLineString|MultiPolygon>} geojson object\n * @param {Function} callback a method that takes (currentLine, featureIndex, multiFeatureIndex, geometryIndex)\n * @example\n * var multiLine = turf.multiLineString([\n *   [[26, 37], [35, 45]],\n *   [[36, 53], [38, 50], [41, 55]]\n * ]);\n *\n * turf.lineEach(multiLine, function (currentLine, featureIndex, multiFeatureIndex, geometryIndex) {\n *   //=currentLine\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n * });\n */\nfunction lineEach(geojson, callback) {\n    // validation\n    if (!geojson) throw new Error('geojson is required');\n\n    flattenEach(geojson, function (feature, featureIndex, multiFeatureIndex) {\n        if (feature.geometry === null) return;\n        var type = feature.geometry.type;\n        var coords = feature.geometry.coordinates;\n        switch (type) {\n        case 'LineString':\n            if (callback(feature, featureIndex, multiFeatureIndex, 0, 0) === false) return false;\n            break;\n        case 'Polygon':\n            for (var geometryIndex = 0; geometryIndex < coords.length; geometryIndex++) {\n                if (callback(helpers.lineString(coords[geometryIndex], feature.properties), featureIndex, multiFeatureIndex, geometryIndex) === false) return false;\n            }\n            break;\n        }\n    });\n}\n\n/**\n * Callback for lineReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback lineReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature<LineString>} currentLine The current LineString|LinearRing being processed.\n * @param {number} featureIndex The current index of the Feature being processed\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed\n * @param {number} geometryIndex The current index of the Geometry being processed\n */\n\n/**\n * Reduce features in any GeoJSON object, similar to Array.reduce().\n *\n * @name lineReduce\n * @param {Geometry|Feature<LineString|Polygon|MultiLineString|MultiPolygon>} geojson object\n * @param {Function} callback a method that takes (previousValue, currentLine, featureIndex, multiFeatureIndex, geometryIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var multiPoly = turf.multiPolygon([\n *   turf.polygon([[[12,48],[2,41],[24,38],[12,48]], [[9,44],[13,41],[13,45],[9,44]]]),\n *   turf.polygon([[[5, 5], [0, 0], [2, 2], [4, 4], [5, 5]]])\n * ]);\n *\n * turf.lineReduce(multiPoly, function (previousValue, currentLine, featureIndex, multiFeatureIndex, geometryIndex) {\n *   //=previousValue\n *   //=currentLine\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n *   return currentLine\n * });\n */\nfunction lineReduce(geojson, callback, initialValue) {\n    var previousValue = initialValue;\n    lineEach(geojson, function (currentLine, featureIndex, multiFeatureIndex, geometryIndex) {\n        if (featureIndex === 0 && initialValue === undefined) previousValue = currentLine;\n        else previousValue = callback(previousValue, currentLine, featureIndex, multiFeatureIndex, geometryIndex);\n    });\n    return previousValue;\n}\n\n/**\n * Finds a particular 2-vertex LineString Segment from a GeoJSON using `@turf/meta` indexes.\n *\n * Negative indexes are permitted.\n * Point & MultiPoint will always return null.\n *\n * @param {FeatureCollection|Feature|Geometry} geojson Any GeoJSON Feature or Geometry\n * @param {Object} [options={}] Optional parameters\n * @param {number} [options.featureIndex=0] Feature Index\n * @param {number} [options.multiFeatureIndex=0] Multi-Feature Index\n * @param {number} [options.geometryIndex=0] Geometry Index\n * @param {number} [options.segmentIndex=0] Segment Index\n * @param {Object} [options.properties={}] Translate Properties to output LineString\n * @param {BBox} [options.bbox={}] Translate BBox to output LineString\n * @param {number|string} [options.id={}] Translate Id to output LineString\n * @returns {Feature<LineString>} 2-vertex GeoJSON Feature LineString\n * @example\n * var multiLine = turf.multiLineString([\n *     [[10, 10], [50, 30], [30, 40]],\n *     [[-10, -10], [-50, -30], [-30, -40]]\n * ]);\n *\n * // First Segment (defaults are 0)\n * turf.findSegment(multiLine);\n * // => Feature<LineString<[[10, 10], [50, 30]]>>\n *\n * // First Segment of 2nd Multi Feature\n * turf.findSegment(multiLine, {multiFeatureIndex: 1});\n * // => Feature<LineString<[[-10, -10], [-50, -30]]>>\n *\n * // Last Segment of Last Multi Feature\n * turf.findSegment(multiLine, {multiFeatureIndex: -1, segmentIndex: -1});\n * // => Feature<LineString<[[-50, -30], [-30, -40]]>>\n */\nfunction findSegment(geojson, options) {\n    // Optional Parameters\n    options = options || {};\n    if (!helpers.isObject(options)) throw new Error('options is invalid');\n    var featureIndex = options.featureIndex || 0;\n    var multiFeatureIndex = options.multiFeatureIndex || 0;\n    var geometryIndex = options.geometryIndex || 0;\n    var segmentIndex = options.segmentIndex || 0;\n\n    // Find FeatureIndex\n    var properties = options.properties;\n    var geometry;\n\n    switch (geojson.type) {\n    case 'FeatureCollection':\n        if (featureIndex < 0) featureIndex = geojson.features.length + featureIndex;\n        properties = properties || geojson.features[featureIndex].properties;\n        geometry = geojson.features[featureIndex].geometry;\n        break;\n    case 'Feature':\n        properties = properties || geojson.properties;\n        geometry = geojson.geometry;\n        break;\n    case 'Point':\n    case 'MultiPoint':\n        return null;\n    case 'LineString':\n    case 'Polygon':\n    case 'MultiLineString':\n    case 'MultiPolygon':\n        geometry = geojson;\n        break;\n    default:\n        throw new Error('geojson is invalid');\n    }\n\n    // Find SegmentIndex\n    if (geometry === null) return null;\n    var coords = geometry.coordinates;\n    switch (geometry.type) {\n    case 'Point':\n    case 'MultiPoint':\n        return null;\n    case 'LineString':\n        if (segmentIndex < 0) segmentIndex = coords.length + segmentIndex - 1;\n        return helpers.lineString([coords[segmentIndex], coords[segmentIndex + 1]], properties, options);\n    case 'Polygon':\n        if (geometryIndex < 0) geometryIndex = coords.length + geometryIndex;\n        if (segmentIndex < 0) segmentIndex = coords[geometryIndex].length + segmentIndex - 1;\n        return helpers.lineString([coords[geometryIndex][segmentIndex], coords[geometryIndex][segmentIndex + 1]], properties, options);\n    case 'MultiLineString':\n        if (multiFeatureIndex < 0) multiFeatureIndex = coords.length + multiFeatureIndex;\n        if (segmentIndex < 0) segmentIndex = coords[multiFeatureIndex].length + segmentIndex - 1;\n        return helpers.lineString([coords[multiFeatureIndex][segmentIndex], coords[multiFeatureIndex][segmentIndex + 1]], properties, options);\n    case 'MultiPolygon':\n        if (multiFeatureIndex < 0) multiFeatureIndex = coords.length + multiFeatureIndex;\n        if (geometryIndex < 0) geometryIndex = coords[multiFeatureIndex].length + geometryIndex;\n        if (segmentIndex < 0) segmentIndex = coords[multiFeatureIndex][geometryIndex].length - segmentIndex - 1;\n        return helpers.lineString([coords[multiFeatureIndex][geometryIndex][segmentIndex], coords[multiFeatureIndex][geometryIndex][segmentIndex + 1]], properties, options);\n    }\n    throw new Error('geojson is invalid');\n}\n\n/**\n * Finds a particular Point from a GeoJSON using `@turf/meta` indexes.\n *\n * Negative indexes are permitted.\n *\n * @param {FeatureCollection|Feature|Geometry} geojson Any GeoJSON Feature or Geometry\n * @param {Object} [options={}] Optional parameters\n * @param {number} [options.featureIndex=0] Feature Index\n * @param {number} [options.multiFeatureIndex=0] Multi-Feature Index\n * @param {number} [options.geometryIndex=0] Geometry Index\n * @param {number} [options.coordIndex=0] Coord Index\n * @param {Object} [options.properties={}] Translate Properties to output Point\n * @param {BBox} [options.bbox={}] Translate BBox to output Point\n * @param {number|string} [options.id={}] Translate Id to output Point\n * @returns {Feature<Point>} 2-vertex GeoJSON Feature Point\n * @example\n * var multiLine = turf.multiLineString([\n *     [[10, 10], [50, 30], [30, 40]],\n *     [[-10, -10], [-50, -30], [-30, -40]]\n * ]);\n *\n * // First Segment (defaults are 0)\n * turf.findPoint(multiLine);\n * // => Feature<Point<[10, 10]>>\n *\n * // First Segment of the 2nd Multi-Feature\n * turf.findPoint(multiLine, {multiFeatureIndex: 1});\n * // => Feature<Point<[-10, -10]>>\n *\n * // Last Segment of last Multi-Feature\n * turf.findPoint(multiLine, {multiFeatureIndex: -1, coordIndex: -1});\n * // => Feature<Point<[-30, -40]>>\n */\nfunction findPoint(geojson, options) {\n    // Optional Parameters\n    options = options || {};\n    if (!helpers.isObject(options)) throw new Error('options is invalid');\n    var featureIndex = options.featureIndex || 0;\n    var multiFeatureIndex = options.multiFeatureIndex || 0;\n    var geometryIndex = options.geometryIndex || 0;\n    var coordIndex = options.coordIndex || 0;\n\n    // Find FeatureIndex\n    var properties = options.properties;\n    var geometry;\n\n    switch (geojson.type) {\n    case 'FeatureCollection':\n        if (featureIndex < 0) featureIndex = geojson.features.length + featureIndex;\n        properties = properties || geojson.features[featureIndex].properties;\n        geometry = geojson.features[featureIndex].geometry;\n        break;\n    case 'Feature':\n        properties = properties || geojson.properties;\n        geometry = geojson.geometry;\n        break;\n    case 'Point':\n    case 'MultiPoint':\n        return null;\n    case 'LineString':\n    case 'Polygon':\n    case 'MultiLineString':\n    case 'MultiPolygon':\n        geometry = geojson;\n        break;\n    default:\n        throw new Error('geojson is invalid');\n    }\n\n    // Find Coord Index\n    if (geometry === null) return null;\n    var coords = geometry.coordinates;\n    switch (geometry.type) {\n    case 'Point':\n        return helpers.point(coords, properties, options);\n    case 'MultiPoint':\n        if (multiFeatureIndex < 0) multiFeatureIndex = coords.length + multiFeatureIndex;\n        return helpers.point(coords[multiFeatureIndex], properties, options);\n    case 'LineString':\n        if (coordIndex < 0) coordIndex = coords.length + coordIndex;\n        return helpers.point(coords[coordIndex], properties, options);\n    case 'Polygon':\n        if (geometryIndex < 0) geometryIndex = coords.length + geometryIndex;\n        if (coordIndex < 0) coordIndex = coords[geometryIndex].length + coordIndex;\n        return helpers.point(coords[geometryIndex][coordIndex], properties, options);\n    case 'MultiLineString':\n        if (multiFeatureIndex < 0) multiFeatureIndex = coords.length + multiFeatureIndex;\n        if (coordIndex < 0) coordIndex = coords[multiFeatureIndex].length + coordIndex;\n        return helpers.point(coords[multiFeatureIndex][coordIndex], properties, options);\n    case 'MultiPolygon':\n        if (multiFeatureIndex < 0) multiFeatureIndex = coords.length + multiFeatureIndex;\n        if (geometryIndex < 0) geometryIndex = coords[multiFeatureIndex].length + geometryIndex;\n        if (coordIndex < 0) coordIndex = coords[multiFeatureIndex][geometryIndex].length - coordIndex;\n        return helpers.point(coords[multiFeatureIndex][geometryIndex][coordIndex], properties, options);\n    }\n    throw new Error('geojson is invalid');\n}\n\nexports.coordEach = coordEach;\nexports.coordReduce = coordReduce;\nexports.propEach = propEach;\nexports.propReduce = propReduce;\nexports.featureEach = featureEach;\nexports.featureReduce = featureReduce;\nexports.coordAll = coordAll;\nexports.geomEach = geomEach;\nexports.geomReduce = geomReduce;\nexports.flattenEach = flattenEach;\nexports.flattenReduce = flattenReduce;\nexports.segmentEach = segmentEach;\nexports.segmentReduce = segmentReduce;\nexports.lineEach = lineEach;\nexports.lineReduce = lineReduce;\nexports.findSegment = findSegment;\nexports.findPoint = findPoint;\n","(function(f){if(typeof exports===\"object\"&&typeof module!==\"undefined\"){module.exports=f()}else if(typeof define===\"function\"&&define.amd){define([],f)}else{var g;if(typeof window!==\"undefined\"){g=window}else if(typeof global!==\"undefined\"){g=global}else if(typeof self!==\"undefined\"){g=self}else{g=this}g.martinez = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){\n'use strict';\n\nvar martinez = require('./src/index');\n\nvar boolean = {\n  union: martinez.union,\n  diff: martinez.diff,\n  xor: martinez.xor,\n  intersection: martinez.intersection\n};\nboolean.default = boolean;\n\nmodule.exports = boolean;\n\n},{\"./src/index\":12}],2:[function(require,module,exports){\n(function (global, factory) {\n\ttypeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :\n\ttypeof define === 'function' && define.amd ? define(factory) :\n\t(global.avl = factory());\n}(this, (function () { 'use strict';\n\n/**\n * Prints tree horizontally\n * @param  {Node}                       root\n * @param  {Function(node:Node):String} [printNode]\n * @return {String}\n */\nfunction print (root, printNode) {\n  if ( printNode === void 0 ) printNode = function (n) { return n.key; };\n\n  var out = [];\n  row(root, '', true, function (v) { return out.push(v); }, printNode);\n  return out.join('');\n}\n\n/**\n * Prints level of the tree\n * @param  {Node}                        root\n * @param  {String}                      prefix\n * @param  {Boolean}                     isTail\n * @param  {Function(in:string):void}    out\n * @param  {Function(node:Node):String}  printNode\n */\nfunction row (root, prefix, isTail, out, printNode) {\n  if (root) {\n    out((\"\" + prefix + (isTail ? ' ' : ' ') + (printNode(root)) + \"\\n\"));\n    var indent = prefix + (isTail ? '    ' : '   ');\n    if (root.left)  { row(root.left,  indent, false, out, printNode); }\n    if (root.right) { row(root.right, indent, true,  out, printNode); }\n  }\n}\n\n\n/**\n * Is the tree balanced (none of the subtrees differ in height by more than 1)\n * @param  {Node}    root\n * @return {Boolean}\n */\nfunction isBalanced(root) {\n  if (root === null) { return true; } // If node is empty then return true\n\n  // Get the height of left and right sub trees\n  var lh = height(root.left);\n  var rh = height(root.right);\n\n  if (Math.abs(lh - rh) <= 1 &&\n      isBalanced(root.left)  &&\n      isBalanced(root.right)) { return true; }\n\n  // If we reach here then tree is not height-balanced\n  return false;\n}\n\n/**\n * The function Compute the 'height' of a tree.\n * Height is the number of nodes along the longest path\n * from the root node down to the farthest leaf node.\n *\n * @param  {Node} node\n * @return {Number}\n */\nfunction height(node) {\n  return node ? (1 + Math.max(height(node.left), height(node.right))) : 0;\n}\n\n// function createNode (parent, left, right, height, key, data) {\n//   return { parent, left, right, balanceFactor: height, key, data };\n// }\n\n/**\n * @typedef {{\n *   parent:        ?Node,\n *   left:          ?Node,\n *   right:         ?Node,\n *   balanceFactor: number,\n *   key:           Key,\n *   data:          Value\n * }} Node\n */\n\n/**\n * @typedef {*} Key\n */\n\n/**\n * @typedef {*} Value\n */\n\n/**\n * Default comparison function\n * @param {Key} a\n * @param {Key} b\n * @returns {number}\n */\nfunction DEFAULT_COMPARE (a, b) { return a > b ? 1 : a < b ? -1 : 0; }\n\n\n/**\n * Single left rotation\n * @param  {Node} node\n * @return {Node}\n */\nfunction rotateLeft (node) {\n  var rightNode = node.right;\n  node.right    = rightNode.left;\n\n  if (rightNode.left) { rightNode.left.parent = node; }\n\n  rightNode.parent = node.parent;\n  if (rightNode.parent) {\n    if (rightNode.parent.left === node) {\n      rightNode.parent.left = rightNode;\n    } else {\n      rightNode.parent.right = rightNode;\n    }\n  }\n\n  node.parent    = rightNode;\n  rightNode.left = node;\n\n  node.balanceFactor += 1;\n  if (rightNode.balanceFactor < 0) {\n    node.balanceFactor -= rightNode.balanceFactor;\n  }\n\n  rightNode.balanceFactor += 1;\n  if (node.balanceFactor > 0) {\n    rightNode.balanceFactor += node.balanceFactor;\n  }\n  return rightNode;\n}\n\n\nfunction rotateRight (node) {\n  var leftNode = node.left;\n  node.left = leftNode.right;\n  if (node.left) { node.left.parent = node; }\n\n  leftNode.parent = node.parent;\n  if (leftNode.parent) {\n    if (leftNode.parent.left === node) {\n      leftNode.parent.left = leftNode;\n    } else {\n      leftNode.parent.right = leftNode;\n    }\n  }\n\n  node.parent    = leftNode;\n  leftNode.right = node;\n\n  node.balanceFactor -= 1;\n  if (leftNode.balanceFactor > 0) {\n    node.balanceFactor -= leftNode.balanceFactor;\n  }\n\n  leftNode.balanceFactor -= 1;\n  if (node.balanceFactor < 0) {\n    leftNode.balanceFactor += node.balanceFactor;\n  }\n\n  return leftNode;\n}\n\n\n// function leftBalance (node) {\n//   if (node.left.balanceFactor === -1) rotateLeft(node.left);\n//   return rotateRight(node);\n// }\n\n\n// function rightBalance (node) {\n//   if (node.right.balanceFactor === 1) rotateRight(node.right);\n//   return rotateLeft(node);\n// }\n\n\nvar AVLTree = function AVLTree (comparator, noDuplicates) {\n  if ( noDuplicates === void 0 ) noDuplicates = false;\n\n  this._comparator = comparator || DEFAULT_COMPARE;\n  this._root = null;\n  this._size = 0;\n  this._noDuplicates = !!noDuplicates;\n};\n\nvar prototypeAccessors = { size: {} };\n\n\n/**\n * Clear the tree\n * @return {AVLTree}\n */\nAVLTree.prototype.destroy = function destroy () {\n  this._root = null;\n  return this;\n};\n\n/**\n * Number of nodes\n * @return {number}\n */\nprototypeAccessors.size.get = function () {\n  return this._size;\n};\n\n\n/**\n * Whether the tree contains a node with the given key\n * @param{Key} key\n * @return {boolean} true/false\n */\nAVLTree.prototype.contains = function contains (key) {\n  if (this._root){\n    var node     = this._root;\n    var comparator = this._comparator;\n    while (node){\n      var cmp = comparator(key, node.key);\n      if    (cmp === 0) { return true; }\n      else if (cmp < 0) { node = node.left; }\n      else              { node = node.right; }\n    }\n  }\n  return false;\n};\n\n\n/* eslint-disable class-methods-use-this */\n\n/**\n * Successor node\n * @param{Node} node\n * @return {?Node}\n */\nAVLTree.prototype.next = function next (node) {\n  var successor = node;\n  if (successor) {\n    if (successor.right) {\n      successor = successor.right;\n      while (successor && successor.left) { successor = successor.left; }\n    } else {\n      successor = node.parent;\n      while (successor && successor.right === node) {\n        node = successor; successor = successor.parent;\n      }\n    }\n  }\n  return successor;\n};\n\n\n/**\n * Predecessor node\n * @param{Node} node\n * @return {?Node}\n */\nAVLTree.prototype.prev = function prev (node) {\n  var predecessor = node;\n  if (predecessor) {\n    if (predecessor.left) {\n      predecessor = predecessor.left;\n      while (predecessor && predecessor.right) { predecessor = predecessor.right; }\n    } else {\n      predecessor = node.parent;\n      while (predecessor && predecessor.left === node) {\n        node = predecessor;\n        predecessor = predecessor.parent;\n      }\n    }\n  }\n  return predecessor;\n};\n/* eslint-enable class-methods-use-this */\n\n\n/**\n * Callback for forEach\n * @callback forEachCallback\n * @param {Node} node\n * @param {number} index\n */\n\n/**\n * @param{forEachCallback} callback\n * @return {AVLTree}\n */\nAVLTree.prototype.forEach = function forEach (callback) {\n  var current = this._root;\n  var s = [], done = false, i = 0;\n\n  while (!done) {\n    // Reach the left most Node of the current Node\n    if (current) {\n      // Place pointer to a tree node on the stack\n      // before traversing the node's left subtree\n      s.push(current);\n      current = current.left;\n    } else {\n      // BackTrack from the empty subtree and visit the Node\n      // at the top of the stack; however, if the stack is\n      // empty you are done\n      if (s.length > 0) {\n        current = s.pop();\n        callback(current, i++);\n\n        // We have visited the node and its left\n        // subtree. Now, it's right subtree's turn\n        current = current.right;\n      } else { done = true; }\n    }\n  }\n  return this;\n};\n\n\n/**\n * Returns all keys in order\n * @return {Array<Key>}\n */\nAVLTree.prototype.keys = function keys () {\n  var current = this._root;\n  var s = [], r = [], done = false;\n\n  while (!done) {\n    if (current) {\n      s.push(current);\n      current = current.left;\n    } else {\n      if (s.length > 0) {\n        current = s.pop();\n        r.push(current.key);\n        current = current.right;\n      } else { done = true; }\n    }\n  }\n  return r;\n};\n\n\n/**\n * Returns `data` fields of all nodes in order.\n * @return {Array<Value>}\n */\nAVLTree.prototype.values = function values () {\n  var current = this._root;\n  var s = [], r = [], done = false;\n\n  while (!done) {\n    if (current) {\n      s.push(current);\n      current = current.left;\n    } else {\n      if (s.length > 0) {\n        current = s.pop();\n        r.push(current.data);\n        current = current.right;\n      } else { done = true; }\n    }\n  }\n  return r;\n};\n\n\n/**\n * Returns node at given index\n * @param{number} index\n * @return {?Node}\n */\nAVLTree.prototype.at = function at (index) {\n  // removed after a consideration, more misleading than useful\n  // index = index % this.size;\n  // if (index < 0) index = this.size - index;\n\n  var current = this._root;\n  var s = [], done = false, i = 0;\n\n  while (!done) {\n    if (current) {\n      s.push(current);\n      current = current.left;\n    } else {\n      if (s.length > 0) {\n        current = s.pop();\n        if (i === index) { return current; }\n        i++;\n        current = current.right;\n      } else { done = true; }\n    }\n  }\n  return null;\n};\n\n\n/**\n * Returns node with the minimum key\n * @return {?Node}\n */\nAVLTree.prototype.minNode = function minNode () {\n  var node = this._root;\n  if (!node) { return null; }\n  while (node.left) { node = node.left; }\n  return node;\n};\n\n\n/**\n * Returns node with the max key\n * @return {?Node}\n */\nAVLTree.prototype.maxNode = function maxNode () {\n  var node = this._root;\n  if (!node) { return null; }\n  while (node.right) { node = node.right; }\n  return node;\n};\n\n\n/**\n * Min key\n * @return {?Key}\n */\nAVLTree.prototype.min = function min () {\n  var node = this._root;\n  if (!node) { return null; }\n  while (node.left) { node = node.left; }\n  return node.key;\n};\n\n\n/**\n * Max key\n * @return {?Key}\n */\nAVLTree.prototype.max = function max () {\n  var node = this._root;\n  if (!node) { return null; }\n  while (node.right) { node = node.right; }\n  return node.key;\n};\n\n\n/**\n * @return {boolean} true/false\n */\nAVLTree.prototype.isEmpty = function isEmpty () {\n  return !this._root;\n};\n\n\n/**\n * Removes and returns the node with smallest key\n * @return {?Node}\n */\nAVLTree.prototype.pop = function pop () {\n  var node = this._root, returnValue = null;\n  if (node) {\n    while (node.left) { node = node.left; }\n    returnValue = { key: node.key, data: node.data };\n    this.remove(node.key);\n  }\n  return returnValue;\n};\n\n\n/**\n * Find node by key\n * @param{Key} key\n * @return {?Node}\n */\nAVLTree.prototype.find = function find (key) {\n  var root = this._root;\n  // if (root === null)  return null;\n  // if (key === root.key) return root;\n\n  var subtree = root, cmp;\n  var compare = this._comparator;\n  while (subtree) {\n    cmp = compare(key, subtree.key);\n    if    (cmp === 0) { return subtree; }\n    else if (cmp < 0) { subtree = subtree.left; }\n    else              { subtree = subtree.right; }\n  }\n\n  return null;\n};\n\n\n/**\n * Insert a node into the tree\n * @param{Key} key\n * @param{Value} [data]\n * @return {?Node}\n */\nAVLTree.prototype.insert = function insert (key, data) {\n    var this$1 = this;\n\n  if (!this._root) {\n    this._root = {\n      parent: null, left: null, right: null, balanceFactor: 0,\n      key: key, data: data\n    };\n    this._size++;\n    return this._root;\n  }\n\n  var compare = this._comparator;\n  var node  = this._root;\n  var parent= null;\n  var cmp   = 0;\n\n  if (this._noDuplicates) {\n    while (node) {\n      cmp = compare(key, node.key);\n      parent = node;\n      if    (cmp === 0) { return null; }\n      else if (cmp < 0) { node = node.left; }\n      else              { node = node.right; }\n    }\n  } else {\n    while (node) {\n      cmp = compare(key, node.key);\n      parent = node;\n      if    (cmp <= 0){ node = node.left; } //return null;\n      else              { node = node.right; }\n    }\n  }\n\n  var newNode = {\n    left: null,\n    right: null,\n    balanceFactor: 0,\n    parent: parent, key: key, data: data\n  };\n  var newRoot;\n  if (cmp <= 0) { parent.left= newNode; }\n  else       { parent.right = newNode; }\n\n  while (parent) {\n    cmp = compare(parent.key, key);\n    if (cmp < 0) { parent.balanceFactor -= 1; }\n    else       { parent.balanceFactor += 1; }\n\n    if      (parent.balanceFactor === 0) { break; }\n    else if (parent.balanceFactor < -1) {\n      // inlined\n      //var newRoot = rightBalance(parent);\n      if (parent.right.balanceFactor === 1) { rotateRight(parent.right); }\n      newRoot = rotateLeft(parent);\n\n      if (parent === this$1._root) { this$1._root = newRoot; }\n      break;\n    } else if (parent.balanceFactor > 1) {\n      // inlined\n      // var newRoot = leftBalance(parent);\n      if (parent.left.balanceFactor === -1) { rotateLeft(parent.left); }\n      newRoot = rotateRight(parent);\n\n      if (parent === this$1._root) { this$1._root = newRoot; }\n      break;\n    }\n    parent = parent.parent;\n  }\n\n  this._size++;\n  return newNode;\n};\n\n\n/**\n * Removes the node from the tree. If not found, returns null.\n * @param{Key} key\n * @return {?Node}\n */\nAVLTree.prototype.remove = function remove (key) {\n    var this$1 = this;\n\n  if (!this._root) { return null; }\n\n  var node = this._root;\n  var compare = this._comparator;\n  var cmp = 0;\n\n  while (node) {\n    cmp = compare(key, node.key);\n    if    (cmp === 0) { break; }\n    else if (cmp < 0) { node = node.left; }\n    else              { node = node.right; }\n  }\n  if (!node) { return null; }\n\n  var returnValue = node.key;\n  var max, min;\n\n  if (node.left) {\n    max = node.left;\n\n    while (max.left || max.right) {\n      while (max.right) { max = max.right; }\n\n      node.key = max.key;\n      node.data = max.data;\n      if (max.left) {\n        node = max;\n        max = max.left;\n      }\n    }\n\n    node.key= max.key;\n    node.data = max.data;\n    node = max;\n  }\n\n  if (node.right) {\n    min = node.right;\n\n    while (min.left || min.right) {\n      while (min.left) { min = min.left; }\n\n      node.key= min.key;\n      node.data = min.data;\n      if (min.right) {\n        node = min;\n        min = min.right;\n      }\n    }\n\n    node.key= min.key;\n    node.data = min.data;\n    node = min;\n  }\n\n  var parent = node.parent;\n  var pp   = node;\n  var newRoot;\n\n  while (parent) {\n    if (parent.left === pp) { parent.balanceFactor -= 1; }\n    else                  { parent.balanceFactor += 1; }\n\n    if      (parent.balanceFactor < -1) {\n      // inlined\n      //var newRoot = rightBalance(parent);\n      if (parent.right.balanceFactor === 1) { rotateRight(parent.right); }\n      newRoot = rotateLeft(parent);\n\n      if (parent === this$1._root) { this$1._root = newRoot; }\n      parent = newRoot;\n    } else if (parent.balanceFactor > 1) {\n      // inlined\n      // var newRoot = leftBalance(parent);\n      if (parent.left.balanceFactor === -1) { rotateLeft(parent.left); }\n      newRoot = rotateRight(parent);\n\n      if (parent === this$1._root) { this$1._root = newRoot; }\n      parent = newRoot;\n    }\n\n    if (parent.balanceFactor === -1 || parent.balanceFactor === 1) { break; }\n\n    pp   = parent;\n    parent = parent.parent;\n  }\n\n  if (node.parent) {\n    if (node.parent.left === node) { node.parent.left= null; }\n    else                         { node.parent.right = null; }\n  }\n\n  if (node === this._root) { this._root = null; }\n\n  this._size--;\n  return returnValue;\n};\n\n\n/**\n * Bulk-load items\n * @param{Array<Key>}keys\n * @param{Array<Value>}[values]\n * @return {AVLTree}\n */\nAVLTree.prototype.load = function load (keys, values) {\n    var this$1 = this;\n    if ( keys === void 0 ) keys = [];\n    if ( values === void 0 ) values = [];\n\n  if (Array.isArray(keys)) {\n    for (var i = 0, len = keys.length; i < len; i++) {\n      this$1.insert(keys[i], values[i]);\n    }\n  }\n  return this;\n};\n\n\n/**\n * Returns true if the tree is balanced\n * @return {boolean}\n */\nAVLTree.prototype.isBalanced = function isBalanced$1 () {\n  return isBalanced(this._root);\n};\n\n\n/**\n * String representation of the tree - primitive horizontal print-out\n * @param{Function(Node):string} [printNode]\n * @return {string}\n */\nAVLTree.prototype.toString = function toString (printNode) {\n  return print(this._root, printNode);\n};\n\nObject.defineProperties( AVLTree.prototype, prototypeAccessors );\n\nreturn AVLTree;\n\n})));\n\n\n},{}],3:[function(require,module,exports){\n'use strict';\n\nmodule.exports = TinyQueue;\nmodule.exports.default = TinyQueue;\n\nfunction TinyQueue(data, compare) {\n    if (!(this instanceof TinyQueue)) return new TinyQueue(data, compare);\n\n    this.data = data || [];\n    this.length = this.data.length;\n    this.compare = compare || defaultCompare;\n\n    if (this.length > 0) {\n        for (var i = (this.length >> 1) - 1; i >= 0; i--) this._down(i);\n    }\n}\n\nfunction defaultCompare(a, b) {\n    return a < b ? -1 : a > b ? 1 : 0;\n}\n\nTinyQueue.prototype = {\n\n    push: function (item) {\n        this.data.push(item);\n        this.length++;\n        this._up(this.length - 1);\n    },\n\n    pop: function () {\n        if (this.length === 0) return undefined;\n\n        var top = this.data[0];\n        this.length--;\n\n        if (this.length > 0) {\n            this.data[0] = this.data[this.length];\n            this._down(0);\n        }\n        this.data.pop();\n\n        return top;\n    },\n\n    peek: function () {\n        return this.data[0];\n    },\n\n    _up: function (pos) {\n        var data = this.data;\n        var compare = this.compare;\n        var item = data[pos];\n\n        while (pos > 0) {\n            var parent = (pos - 1) >> 1;\n            var current = data[parent];\n            if (compare(item, current) >= 0) break;\n            data[pos] = current;\n            pos = parent;\n        }\n\n        data[pos] = item;\n    },\n\n    _down: function (pos) {\n        var data = this.data;\n        var compare = this.compare;\n        var halfLength = this.length >> 1;\n        var item = data[pos];\n\n        while (pos < halfLength) {\n            var left = (pos << 1) + 1;\n            var right = left + 1;\n            var best = data[left];\n\n            if (right < this.length && compare(data[right], best) < 0) {\n                left = right;\n                best = data[right];\n            }\n            if (compare(best, item) >= 0) break;\n\n            data[pos] = best;\n            pos = left;\n        }\n\n        data[pos] = item;\n    }\n};\n\n},{}],4:[function(require,module,exports){\n'use strict';\n\nvar signedArea = require('./signed_area');\n// var equals = require('./equals');\n\n/**\n * @param  {SweepEvent} e1\n * @param  {SweepEvent} e2\n * @return {Number}\n */\nmodule.exports = function compareEvents(e1, e2) {\n  var p1 = e1.point;\n  var p2 = e2.point;\n\n  // Different x-coordinate\n  if (p1[0] > p2[0]) return 1;\n  if (p1[0] < p2[0]) return -1;\n\n  // Different points, but same x-coordinate\n  // Event with lower y-coordinate is processed first\n  if (p1[1] !== p2[1]) return p1[1] > p2[1] ? 1 : -1;\n\n  return specialCases(e1, e2, p1, p2);\n};\n\n\n/* eslint-disable no-unused-vars */\nfunction specialCases(e1, e2, p1, p2) {\n  // Same coordinates, but one is a left endpoint and the other is\n  // a right endpoint. The right endpoint is processed first\n  if (e1.left !== e2.left)\n    return e1.left ? 1 : -1;\n\n  // var p2 = e1.otherEvent.point, p3 = e2.otherEvent.point;\n  // var sa = (p1[0] - p3[0]) * (p2[1] - p3[1]) - (p2[0] - p3[0]) * (p1[1] - p3[1])\n  // Same coordinates, both events\n  // are left endpoints or right endpoints.\n  // not collinear\n  if (signedArea(p1, e1.otherEvent.point, e2.otherEvent.point) !== 0) {\n    // the event associate to the bottom segment is processed first\n    return (!e1.isBelow(e2.otherEvent.point)) ? 1 : -1;\n  }\n\n  return (!e1.isSubject && e2.isSubject) ? 1 : -1;\n}\n/* eslint-enable no-unused-vars */\n\n},{\"./signed_area\":16}],5:[function(require,module,exports){\n'use strict';\n\nvar signedArea    = require('./signed_area');\nvar compareEvents = require('./compare_events');\nvar equals        = require('./equals');\n\n\n/**\n * @param  {SweepEvent} le1\n * @param  {SweepEvent} le2\n * @return {Number}\n */\nmodule.exports = function compareSegments(le1, le2) {\n  if (le1 === le2) return 0;\n\n  // Segments are not collinear\n  if (signedArea(le1.point, le1.otherEvent.point, le2.point) !== 0 ||\n    signedArea(le1.point, le1.otherEvent.point, le2.otherEvent.point) !== 0) {\n\n    // If they share their left endpoint use the right endpoint to sort\n    if (equals(le1.point, le2.point)) return le1.isBelow(le2.otherEvent.point) ? -1 : 1;\n\n    // Different left endpoint: use the left endpoint to sort\n    if (le1.point[0] === le2.point[0]) return le1.point[1] < le2.point[1] ? -1 : 1;\n\n    // has the line segment associated to e1 been inserted\n    // into S after the line segment associated to e2 ?\n    if (compareEvents(le1, le2) === 1) return le2.isAbove(le1.point) ? -1 : 1;\n\n    // The line segment associated to e2 has been inserted\n    // into S after the line segment associated to e1\n    return le1.isBelow(le2.point) ? -1 : 1;\n  }\n\n  if (le1.isSubject === le2.isSubject) { // same polygon\n    var p1 = le1.point, p2 = le2.point;\n    if (p1[0] === p2[0] && p1[1] === p2[1]/*equals(le1.point, le2.point)*/) {\n      p1 = le1.otherEvent.point; p2 = le2.otherEvent.point;\n      if (p1[0] === p2[0] && p1[1] === p2[1]) return 0;\n      else return le1.contourId > le2.contourId ? 1 : -1;\n    }\n  } else { // Segments are collinear, but belong to separate polygons\n    return le1.isSubject ? -1 : 1;\n  }\n\n  return compareEvents(le1, le2) === 1 ? 1 : -1;\n};\n\n},{\"./compare_events\":4,\"./equals\":10,\"./signed_area\":16}],6:[function(require,module,exports){\n'use strict';\n\nvar edgeType = require('./edge_type');\nvar operationType = require('./operation');\n\nvar INTERSECTION = operationType.INTERSECTION;\nvar UNION        = operationType.UNION;\nvar DIFFERENCE   = operationType.DIFFERENCE;\nvar XOR          = operationType.XOR;\n\n/**\n * @param  {SweepEvent} event\n * @param  {SweepEvent} prev\n * @param  {Operation} operation\n */\nmodule.exports = function computeFields(event, prev, operation) {\n  // compute inOut and otherInOut fields\n  if (prev === null) {\n    event.inOut      = false;\n    event.otherInOut = true;\n\n  // previous line segment in sweepline belongs to the same polygon\n  } else {\n    if (event.isSubject === prev.isSubject) {\n      event.inOut      = !prev.inOut;\n      event.otherInOut = prev.otherInOut;\n\n    // previous line segment in sweepline belongs to the clipping polygon\n    } else {\n      event.inOut      = !prev.otherInOut;\n      event.otherInOut = prev.isVertical() ? !prev.inOut : prev.inOut;\n    }\n\n    // compute prevInResult field\n    if (prev) {\n      event.prevInResult = (!inResult(prev, operation) || prev.isVertical()) ?\n         prev.prevInResult : prev;\n    }\n  }\n\n  // check if the line segment belongs to the Boolean operation\n  event.inResult = inResult(event, operation);\n};\n\n\n/* eslint-disable indent */\nfunction inResult(event, operation) {\n  switch (event.type) {\n    case edgeType.NORMAL:\n      switch (operation) {\n        case INTERSECTION:\n          return !event.otherInOut;\n        case UNION:\n          return event.otherInOut;\n        case DIFFERENCE:\n          // return (event.isSubject && !event.otherInOut) ||\n          //         (!event.isSubject && event.otherInOut);\n          return (event.isSubject && event.otherInOut) ||\n                  (!event.isSubject && !event.otherInOut);\n        case XOR:\n          return true;\n      }\n      break;\n    case edgeType.SAME_TRANSITION:\n      return operation === INTERSECTION || operation === UNION;\n    case edgeType.DIFFERENT_TRANSITION:\n      return operation === DIFFERENCE;\n    case edgeType.NON_CONTRIBUTING:\n      return false;\n  }\n  return false;\n}\n/* eslint-enable indent */\n\n},{\"./edge_type\":9,\"./operation\":13}],7:[function(require,module,exports){\n'use strict';\n\n// var equals = require('./equals');\nvar compareEvents = require('./compare_events');\nvar operationType = require('./operation');\n\n/**\n * @param  {Array.<SweepEvent>} sortedEvents\n * @return {Array.<SweepEvent>}\n */\nfunction orderEvents(sortedEvents) {\n  var event, i, len, tmp;\n  var resultEvents = [];\n  for (i = 0, len = sortedEvents.length; i < len; i++) {\n    event = sortedEvents[i];\n    if ((event.left && event.inResult) ||\n      (!event.left && event.otherEvent.inResult)) {\n      resultEvents.push(event);\n    }\n  }\n  // Due to overlapping edges the resultEvents array can be not wholly sorted\n  var sorted = false;\n  while (!sorted) {\n    sorted = true;\n    for (i = 0, len = resultEvents.length; i < len; i++) {\n      if ((i + 1) < len &&\n        compareEvents(resultEvents[i], resultEvents[i + 1]) === 1) {\n        tmp = resultEvents[i];\n        resultEvents[i] = resultEvents[i + 1];\n        resultEvents[i + 1] = tmp;\n        sorted = false;\n      }\n    }\n  }\n\n  for (i = 0, len = resultEvents.length; i < len; i++) {\n    event = resultEvents[i];\n    event.pos = i;\n\n    if (!event.left) {\n      tmp = event.pos;\n      event.pos = event.otherEvent.pos;\n      event.otherEvent.pos = tmp;\n    }\n  }\n\n  return resultEvents;\n}\n\n\n/**\n * @param  {Number} pos\n * @param  {Array.<SweepEvent>} resultEvents\n * @param  {Object>}    processed\n * @return {Number}\n */\nfunction nextPos(pos, resultEvents, processed, origIndex) {\n  var newPos = pos + 1;\n  var length = resultEvents.length;\n  if (newPos > length - 1) return pos - 1;\n  var p  = resultEvents[pos].point;\n  var p1 = resultEvents[newPos].point;\n\n\n  // while in range and not the current one by value\n  while (newPos < length && p1[0] === p[0] && p1[1] === p[1]) {\n    if (!processed[newPos]) {\n      return newPos;\n    } else   {\n      newPos++;\n    }\n    p1 = resultEvents[newPos].point;\n  }\n\n  newPos = pos - 1;\n\n  while (processed[newPos] && newPos >= origIndex) {\n    newPos--;\n  }\n  return newPos;\n}\n\n\n/**\n * @param  {Array.<SweepEvent>} sortedEvents\n * @return {Array.<*>} polygons\n */\nmodule.exports = function connectEdges(sortedEvents, operation) {\n  var i, len;\n  var resultEvents = orderEvents(sortedEvents);\n\n  // \"false\"-filled array\n  var processed = {};\n  var result = [];\n  var event;\n\n  for (i = 0, len = resultEvents.length; i < len; i++) {\n    if (processed[i]) continue;\n    var contour = [[]];\n\n    if (!resultEvents[i].isExteriorRing) {\n      if (operation === operationType.DIFFERENCE && !resultEvents[i].isSubject && result.length === 0) {\n        result.push(contour);\n      } else if (result.length === 0) {\n        result.push([[contour]]);\n      } else {\n        result[result.length - 1].push(contour[0]);\n      }\n    } else if (operation === operationType.DIFFERENCE && !resultEvents[i].isSubject && result.length > 1) {\n      result[result.length - 1].push(contour[0]);\n    } else {\n      result.push(contour);\n    }\n\n    var ringId = result.length - 1;\n    var pos = i;\n\n    var initial = resultEvents[i].point;\n    contour[0].push(initial);\n\n    while (pos >= i) {\n      event = resultEvents[pos];\n      processed[pos] = true;\n\n      if (event.left) {\n        event.resultInOut = false;\n        event.contourId   = ringId;\n      } else {\n        event.otherEvent.resultInOut = true;\n        event.otherEvent.contourId   = ringId;\n      }\n\n      pos = event.pos;\n      processed[pos] = true;\n      contour[0].push(resultEvents[pos].point);\n      pos = nextPos(pos, resultEvents, processed, i);\n    }\n\n    pos = pos === -1 ? i : pos;\n\n    event = resultEvents[pos];\n    processed[pos] = processed[event.pos] = true;\n    event.otherEvent.resultInOut = true;\n    event.otherEvent.contourId   = ringId;\n  }\n\n  // for (i = 0, len = result.length; i < len; i++) {\n  //   var polygon = result[i];\n  //   for (var j = 0, jj = polygon.length; j < jj; j++) {\n  //     var polygonContour = polygon[j];\n  //     for (var k = 0, kk = polygonContour.length; k < kk; k++) {\n  //       var coords = polygonContour[k];\n  //       if (typeof coords[0] !== 'number') {\n  //         polygon.splice(j, 1);\n  //         polygon.push(coords);\n  //       }\n  //     }\n  //   }\n  // }\n\n  // Handle if the result is a polygon (eg not multipoly)\n  // Commented it again, let's see what do we mean by that\n  // if (result.length === 1) result = result[0];\n  return result;\n};\n\n},{\"./compare_events\":4,\"./operation\":13}],8:[function(require,module,exports){\n'use strict';\n\nvar SweepEvent    = require('./sweep_event');\nvar equals        = require('./equals');\nvar compareEvents = require('./compare_events');\n\n/**\n * @param  {SweepEvent} se\n * @param  {Array.<Number>} p\n * @param  {Queue} queue\n * @return {Queue}\n */\nmodule.exports = function divideSegment(se, p, queue)  {\n  var r = new SweepEvent(p, false, se,            se.isSubject);\n  var l = new SweepEvent(p, true,  se.otherEvent, se.isSubject);\n\n  if (equals(se.point, se.otherEvent.point)) {\n    console.warn('what is that, a collapsed segment?', se);\n  }\n\n  r.contourId = l.contourId = se.contourId;\n\n  // avoid a rounding error. The left event would be processed after the right event\n  if (compareEvents(l, se.otherEvent) > 0) {\n    se.otherEvent.left = true;\n    l.left = false;\n  }\n\n  // avoid a rounding error. The left event would be processed after the right event\n  // if (compareEvents(se, r) > 0) {}\n\n  se.otherEvent.otherEvent = l;\n  se.otherEvent = r;\n\n  queue.push(l);\n  queue.push(r);\n\n  return queue;\n};\n\n},{\"./compare_events\":4,\"./equals\":10,\"./sweep_event\":18}],9:[function(require,module,exports){\n'use strict';\n\nmodule.exports = {\n  NORMAL:               0,\n  NON_CONTRIBUTING:     1,\n  SAME_TRANSITION:      2,\n  DIFFERENT_TRANSITION: 3\n};\n\n},{}],10:[function(require,module,exports){\n'use strict';\n\n// var EPSILON = 1e-9;\n// var abs = Math.abs;\n\nmodule.exports = function equals(p1, p2) {\n  if (p1[0] === p2[0]) {\n    if (p1[1] === p2[1]) {\n      return true;\n    } else {\n      return false;\n    }\n  }\n  return false;\n};\n\n// TODO https://github.com/w8r/martinez/issues/6#issuecomment-262847164\n// Precision problem.\n//\n// module.exports = function equals(p1, p2) {\n//   return abs(p1[0] - p2[0]) <= EPSILON && abs(p1[1] - p2[1]) <= EPSILON;\n// };\n\n},{}],11:[function(require,module,exports){\n'use strict';\n\nvar Queue           = require('tinyqueue');\nvar SweepEvent      = require('./sweep_event');\nvar compareEvents   = require('./compare_events');\nvar operations      = require('./operation');\n\nvar max = Math.max;\nvar min = Math.min;\n\nvar contourId = 0;\n\n\nfunction processPolygon(contourOrHole, isSubject, depth, Q, bbox, isExteriorRing) {\n  var i, len, s1, s2, e1, e2;\n  for (i = 0, len = contourOrHole.length - 1; i < len; i++) {\n    s1 = contourOrHole[i];\n    s2 = contourOrHole[i + 1];\n    e1 = new SweepEvent(s1, false, undefined, isSubject);\n    e2 = new SweepEvent(s2, false, e1,        isSubject);\n    e1.otherEvent = e2;\n\n    if (s1[0] === s2[0] && s1[1] === s2[1]) {\n      continue; // skip collapsed edges, or it breaks\n    }\n\n    e1.contourId = e2.contourId = depth;\n    if (!isExteriorRing) {\n      e1.isExteriorRing = false;\n      e2.isExteriorRing = false;\n    }\n    if (compareEvents(e1, e2) > 0) {\n      e2.left = true;\n    } else {\n      e1.left = true;\n    }\n\n    var x = s1[0], y = s1[1];\n    bbox[0] = min(bbox[0], x);\n    bbox[1] = min(bbox[1], y);\n    bbox[2] = max(bbox[2], x);\n    bbox[3] = max(bbox[3], y);\n\n    // Pushing it so the queue is sorted from left to right,\n    // with object on the left having the highest priority.\n    Q.push(e1);\n    Q.push(e2);\n  }\n}\n\n\nmodule.exports = function fillQueue(subject, clipping, sbbox, cbbox, operation) {\n  var eventQueue = new Queue(null, compareEvents);\n  var polygonSet, isExteriorRing, i, ii, j, jj; //, k, kk;\n\n  for (i = 0, ii = subject.length; i < ii; i++) {\n    polygonSet = subject[i];\n    for (j = 0, jj = polygonSet.length; j < jj; j++) {\n      isExteriorRing = j === 0;\n      if (isExteriorRing) contourId++;\n      processPolygon(polygonSet[j], true, contourId, eventQueue, sbbox, isExteriorRing);\n    }\n  }\n\n  for (i = 0, ii = clipping.length; i < ii; i++) {\n    polygonSet = clipping[i];\n    for (j = 0, jj = polygonSet.length; j < jj; j++) {\n      isExteriorRing = j === 0;\n      if (operation === operations.DIFFERENCE) isExteriorRing = false;\n      if (isExteriorRing) contourId++;\n      processPolygon(polygonSet[j], false, contourId, eventQueue, cbbox, isExteriorRing);\n    }\n  }\n\n  return eventQueue;\n};\n\n},{\"./compare_events\":4,\"./operation\":13,\"./sweep_event\":18,\"tinyqueue\":3}],12:[function(require,module,exports){\n'use strict';\n\nvar subdivideSegments = require('./subdivide_segments');\nvar connectEdges      = require('./connect_edges');\nvar fillQueue         = require('./fill_queue');\nvar operations        = require('./operation');\n\nvar EMPTY = [];\n\n\nfunction trivialOperation(subject, clipping, operation) {\n  var result = null;\n  if (subject.length * clipping.length === 0) {\n    if        (operation === operations.INTERSECTION) {\n      result = EMPTY;\n    } else if (operation === operations.DIFFERENCE) {\n      result = subject;\n    } else if (operation === operations.UNION ||\n               operation === operations.XOR) {\n      result = (subject.length === 0) ? clipping : subject;\n    }\n  }\n  return result;\n}\n\n\nfunction compareBBoxes(subject, clipping, sbbox, cbbox, operation) {\n  var result = null;\n  if (sbbox[0] > cbbox[2] ||\n      cbbox[0] > sbbox[2] ||\n      sbbox[1] > cbbox[3] ||\n      cbbox[1] > sbbox[3]) {\n    if        (operation === operations.INTERSECTION) {\n      result = EMPTY;\n    } else if (operation === operations.DIFFERENCE) {\n      result = subject;\n    } else if (operation === operations.UNION ||\n               operation === operations.XOR) {\n      result = subject.concat(clipping);\n    }\n  }\n  return result;\n}\n\n\nfunction boolean(subject, clipping, operation) {\n  if (typeof subject[0][0][0] === 'number') {\n    subject = [subject];\n  }\n  if (typeof clipping[0][0][0] === 'number') {\n    clipping = [clipping];\n  }\n  var trivial = trivialOperation(subject, clipping, operation);\n  if (trivial) {\n    return trivial === EMPTY ? null : trivial;\n  }\n  var sbbox = [Infinity, Infinity, -Infinity, -Infinity];\n  var cbbox = [Infinity, Infinity, -Infinity, -Infinity];\n\n  //console.time('fill queue');\n  var eventQueue = fillQueue(subject, clipping, sbbox, cbbox, operation);\n  //console.timeEnd('fill queue');\n\n  trivial = compareBBoxes(subject, clipping, sbbox, cbbox, operation);\n  if (trivial) {\n    return trivial === EMPTY ? null : trivial;\n  }\n  //console.time('subdivide edges');\n  var sortedEvents = subdivideSegments(eventQueue, subject, clipping, sbbox, cbbox, operation);\n  //console.timeEnd('subdivide edges');\n\n  //console.time('connect vertices');\n  var result = connectEdges(sortedEvents, operation);\n  //console.timeEnd('connect vertices');\n  return result;\n}\n\nboolean.union = function (subject, clipping) {\n  return boolean(subject, clipping, operations.UNION);\n};\n\n\nboolean.diff = function (subject, clipping) {\n  return boolean(subject, clipping, operations.DIFFERENCE);\n};\n\n\nboolean.xor = function (subject, clipping) {\n  return boolean(subject, clipping, operations.XOR);\n};\n\n\nboolean.intersection = function (subject, clipping) {\n  return boolean(subject, clipping, operations.INTERSECTION);\n};\n\n\n/**\n * @enum {Number}\n */\nboolean.operations = operations;\n\n\nmodule.exports = boolean;\nmodule.exports.default = boolean;\n\n},{\"./connect_edges\":7,\"./fill_queue\":11,\"./operation\":13,\"./subdivide_segments\":17}],13:[function(require,module,exports){\n'use strict';\n\nmodule.exports = {\n  INTERSECTION: 0,\n  UNION:        1,\n  DIFFERENCE:   2,\n  XOR:          3\n};\n\n},{}],14:[function(require,module,exports){\n'use strict';\n\nvar divideSegment = require('./divide_segment');\nvar intersection  = require('./segment_intersection');\nvar equals        = require('./equals');\nvar compareEvents = require('./compare_events');\nvar edgeType      = require('./edge_type');\n\n/**\n * @param  {SweepEvent} se1\n * @param  {SweepEvent} se2\n * @param  {Queue}      queue\n * @return {Number}\n */\nmodule.exports = function possibleIntersection(se1, se2, queue) {\n  // that disallows self-intersecting polygons,\n  // did cost us half a day, so I'll leave it\n  // out of respect\n  // if (se1.isSubject === se2.isSubject) return;\n  var inter = intersection(\n    se1.point, se1.otherEvent.point,\n    se2.point, se2.otherEvent.point\n  );\n\n  var nintersections = inter ? inter.length : 0;\n  if (nintersections === 0) return 0; // no intersection\n\n  // the line segments intersect at an endpoint of both line segments\n  if ((nintersections === 1) &&\n      (equals(se1.point, se2.point) ||\n       equals(se1.otherEvent.point, se2.otherEvent.point))) {\n    return 0;\n  }\n\n  if (nintersections === 2 && se1.isSubject === se2.isSubject) {\n    // if(se1.contourId === se2.contourId){\n    // console.warn('Edges of the same polygon overlap',\n    //   se1.point, se1.otherEvent.point, se2.point, se2.otherEvent.point);\n    // }\n    //throw new Error('Edges of the same polygon overlap');\n    return 0;\n  }\n\n  // The line segments associated to se1 and se2 intersect\n  if (nintersections === 1) {\n\n    // if the intersection point is not an endpoint of se1\n    if (!equals(se1.point, inter[0]) && !equals(se1.otherEvent.point, inter[0])) {\n      divideSegment(se1, inter[0], queue);\n    }\n\n    // if the intersection point is not an endpoint of se2\n    if (!equals(se2.point, inter[0]) && !equals(se2.otherEvent.point, inter[0])) {\n      divideSegment(se2, inter[0], queue);\n    }\n    return 1;\n  }\n\n  // The line segments associated to se1 and se2 overlap\n  var events        = [];\n  var leftCoincide  = false;\n  var rightCoincide = false;\n\n  if (equals(se1.point, se2.point)) {\n    leftCoincide = true; // linked\n  } else if (compareEvents(se1, se2) === 1) {\n    events.push(se2, se1);\n  } else {\n    events.push(se1, se2);\n  }\n\n  if (equals(se1.otherEvent.point, se2.otherEvent.point)) {\n    rightCoincide = true;\n  } else if (compareEvents(se1.otherEvent, se2.otherEvent) === 1) {\n    events.push(se2.otherEvent, se1.otherEvent);\n  } else {\n    events.push(se1.otherEvent, se2.otherEvent);\n  }\n\n  if ((leftCoincide && rightCoincide) || leftCoincide) {\n    // both line segments are equal or share the left endpoint\n    se2.type = edgeType.NON_CONTRIBUTING;\n    se1.type = (se2.inOut === se1.inOut) ?\n      edgeType.SAME_TRANSITION :\n      edgeType.DIFFERENT_TRANSITION;\n\n    if (leftCoincide && !rightCoincide) {\n      // honestly no idea, but changing events selection from [2, 1]\n      // to [0, 1] fixes the overlapping self-intersecting polygons issue\n      divideSegment(events[1].otherEvent, events[0].point, queue);\n    }\n    return 2;\n  }\n\n  // the line segments share the right endpoint\n  if (rightCoincide) {\n    divideSegment(events[0], events[1].point, queue);\n    return 3;\n  }\n\n  // no line segment includes totally the other one\n  if (events[0] !== events[3].otherEvent) {\n    divideSegment(events[0], events[1].point, queue);\n    divideSegment(events[1], events[2].point, queue);\n    return 3;\n  }\n\n  // one line segment includes the other one\n  divideSegment(events[0], events[1].point, queue);\n  divideSegment(events[3].otherEvent, events[2].point, queue);\n\n  return 3;\n};\n\n},{\"./compare_events\":4,\"./divide_segment\":8,\"./edge_type\":9,\"./equals\":10,\"./segment_intersection\":15}],15:[function(require,module,exports){\n'use strict';\n\nvar EPSILON = 1e-9;\n\n/**\n * Finds the magnitude of the cross product of two vectors (if we pretend\n * they're in three dimensions)\n *\n * @param {Object} a First vector\n * @param {Object} b Second vector\n * @private\n * @returns {Number} The magnitude of the cross product\n */\nfunction crossProduct(a, b) {\n  return a[0] * b[1] - a[1] * b[0];\n}\n\n/**\n * Finds the dot product of two vectors.\n *\n * @param {Object} a First vector\n * @param {Object} b Second vector\n * @private\n * @returns {Number} The dot product\n */\nfunction dotProduct(a, b) {\n  return a[0] * b[0] + a[1] * b[1];\n}\n\n/**\n * Finds the intersection (if any) between two line segments a and b, given the\n * line segments' end points a1, a2 and b1, b2.\n *\n * This algorithm is based on Schneider and Eberly.\n * http://www.cimec.org.ar/~ncalvo/Schneider_Eberly.pdf\n * Page 244.\n *\n * @param {Array.<Number>} a1 point of first line\n * @param {Array.<Number>} a2 point of first line\n * @param {Array.<Number>} b1 point of second line\n * @param {Array.<Number>} b2 point of second line\n * @param {Boolean=}       noEndpointTouch whether to skip single touchpoints\n *                                         (meaning connected segments) as\n *                                         intersections\n * @returns {Array.<Array.<Number>>|Null} If the lines intersect, the point of\n * intersection. If they overlap, the two end points of the overlapping segment.\n * Otherwise, null.\n */\nmodule.exports = function (a1, a2, b1, b2, noEndpointTouch) {\n  // The algorithm expects our lines in the form P + sd, where P is a point,\n  // s is on the interval [0, 1], and d is a vector.\n  // We are passed two points. P can be the first point of each pair. The\n  // vector, then, could be thought of as the distance (in x and y components)\n  // from the first point to the second point.\n  // So first, let's make our vectors:\n  var va = [a2[0] - a1[0], a2[1] - a1[1]];\n  var vb = [b2[0] - b1[0], b2[1] - b1[1]];\n  // We also define a function to convert back to regular point form:\n\n  /* eslint-disable arrow-body-style */\n\n  function toPoint(p, s, d) {\n    return [\n      p[0] + s * d[0],\n      p[1] + s * d[1]\n    ];\n  }\n\n  /* eslint-enable arrow-body-style */\n\n  // The rest is pretty much a straight port of the algorithm.\n  var e = [b1[0] - a1[0], b1[1] - a1[1]];\n  var kross    = crossProduct(va, vb);\n  var sqrKross = kross * kross;\n  var sqrLenA  = dotProduct(va, va);\n  var sqrLenB  = dotProduct(vb, vb);\n\n  // Check for line intersection. This works because of the properties of the\n  // cross product -- specifically, two vectors are parallel if and only if the\n  // cross product is the 0 vector. The full calculation involves relative error\n  // to account for possible very small line segments. See Schneider & Eberly\n  // for details.\n  if (sqrKross > EPSILON * sqrLenA * sqrLenB) {\n    // If they're not parallel, then (because these are line segments) they\n    // still might not actually intersect. This code checks that the\n    // intersection point of the lines is actually on both line segments.\n    var s = crossProduct(e, vb) / kross;\n    if (s < 0 || s > 1) {\n      // not on line segment a\n      return null;\n    }\n    var t = crossProduct(e, va) / kross;\n    if (t < 0 || t > 1) {\n      // not on line segment b\n      return null;\n    }\n    return noEndpointTouch ? null : [toPoint(a1, s, va)];\n  }\n\n  // If we've reached this point, then the lines are either parallel or the\n  // same, but the segments could overlap partially or fully, or not at all.\n  // So we need to find the overlap, if any. To do that, we can use e, which is\n  // the (vector) difference between the two initial points. If this is parallel\n  // with the line itself, then the two lines are the same line, and there will\n  // be overlap.\n  var sqrLenE = dotProduct(e, e);\n  kross = crossProduct(e, va);\n  sqrKross = kross * kross;\n\n  if (sqrKross > EPSILON * sqrLenA * sqrLenE) {\n    // Lines are just parallel, not the same. No overlap.\n    return null;\n  }\n\n  var sa = dotProduct(va, e) / sqrLenA;\n  var sb = sa + dotProduct(va, vb) / sqrLenA;\n  var smin = Math.min(sa, sb);\n  var smax = Math.max(sa, sb);\n\n  // this is, essentially, the FindIntersection acting on floats from\n  // Schneider & Eberly, just inlined into this function.\n  if (smin <= 1 && smax >= 0) {\n\n    // overlap on an end point\n    if (smin === 1) {\n      return noEndpointTouch ? null : [toPoint(a1, smin > 0 ? smin : 0, va)];\n    }\n\n    if (smax === 0) {\n      return noEndpointTouch ? null : [toPoint(a1, smax < 1 ? smax : 1, va)];\n    }\n\n    if (noEndpointTouch && smin === 0 && smax === 1) return null;\n\n    // There's overlap on a segment -- two points of intersection. Return both.\n    return [\n      toPoint(a1, smin > 0 ? smin : 0, va),\n      toPoint(a1, smax < 1 ? smax : 1, va),\n    ];\n  }\n\n  return null;\n};\n\n},{}],16:[function(require,module,exports){\n'use strict';\n\n/**\n * Signed area of the triangle (p0, p1, p2)\n * @param  {Array.<Number>} p0\n * @param  {Array.<Number>} p1\n * @param  {Array.<Number>} p2\n * @return {Number}\n */\nmodule.exports = function signedArea(p0, p1, p2) {\n  return (p0[0] - p2[0]) * (p1[1] - p2[1]) - (p1[0] - p2[0]) * (p0[1] - p2[1]);\n};\n\n},{}],17:[function(require,module,exports){\n'use strict';\n\nvar Tree                 = require('avl');\nvar computeFields        = require('./compute_fields');\nvar possibleIntersection = require('./possible_intersection');\nvar compareSegments      = require('./compare_segments');\nvar operations           = require('./operation');\n\n\nmodule.exports = function subdivide(eventQueue, subject, clipping, sbbox, cbbox, operation) {\n  var sweepLine = new Tree(compareSegments);\n  var sortedEvents = [];\n\n  var rightbound = Math.min(sbbox[2], cbbox[2]);\n\n  var prev, next, begin;\n\n  var INTERSECTION = operations.INTERSECTION;\n  var DIFFERENCE   = operations.DIFFERENCE;\n\n  while (eventQueue.length) {\n    var event = eventQueue.pop();\n    sortedEvents.push(event);\n\n    // optimization by bboxes for intersection and difference goes here\n    if ((operation === INTERSECTION && event.point[0] > rightbound) ||\n        (operation === DIFFERENCE   && event.point[0] > sbbox[2])) {\n      break;\n    }\n\n    if (event.left) {\n      next  = prev = sweepLine.insert(event);\n      begin = sweepLine.minNode();\n\n      if (prev !== begin) prev = sweepLine.prev(prev);\n      else                prev = null;\n\n      next = sweepLine.next(next);\n\n      var prevEvent = prev ? prev.key : null;\n      var prevprevEvent;\n      computeFields(event, prevEvent, operation);\n      if (next) {\n        if (possibleIntersection(event, next.key, eventQueue) === 2) {\n          computeFields(event, prevEvent, operation);\n          computeFields(event, next.key, operation);\n        }\n      }\n\n      if (prev) {\n        if (possibleIntersection(prev.key, event, eventQueue) === 2) {\n          var prevprev = prev;\n          if (prevprev !== begin) prevprev = sweepLine.prev(prevprev);\n          else                    prevprev = null;\n\n          prevprevEvent = prevprev ? prevprev.key : null;\n          computeFields(prevEvent, prevprevEvent, operation);\n          computeFields(event,     prevEvent,     operation);\n        }\n      }\n    } else {\n      event = event.otherEvent;\n      next = prev = sweepLine.find(event);\n\n      if (prev && next) {\n\n        if (prev !== begin) prev = sweepLine.prev(prev);\n        else                prev = null;\n\n        next = sweepLine.next(next);\n        sweepLine.remove(event);\n\n        if (next && prev) {\n          possibleIntersection(prev.key, next.key, eventQueue);\n        }\n      }\n    }\n  }\n  return sortedEvents;\n};\n\n},{\"./compare_segments\":5,\"./compute_fields\":6,\"./operation\":13,\"./possible_intersection\":14,\"avl\":2}],18:[function(require,module,exports){\n'use strict';\n\n//var signedArea = require('./signed_area');\nvar EdgeType   = require('./edge_type');\n\n/**\n * Sweepline event\n *\n * @class {SweepEvent}\n * @param {Array.<Number>}  point\n * @param {Boolean}         left\n * @param {SweepEvent=}     otherEvent\n * @param {Boolean}         isSubject\n * @param {Number}          edgeType\n */\nfunction SweepEvent(point, left, otherEvent, isSubject, edgeType) {\n\n  /**\n   * Is left endpoint?\n   * @type {Boolean}\n   */\n  this.left = left;\n\n  /**\n   * @type {Array.<Number>}\n   */\n  this.point = point;\n\n  /**\n   * Other edge reference\n   * @type {SweepEvent}\n   */\n  this.otherEvent = otherEvent;\n\n  /**\n   * Belongs to source or clipping polygon\n   * @type {Boolean}\n   */\n  this.isSubject = isSubject;\n\n  /**\n   * Edge contribution type\n   * @type {Number}\n   */\n  this.type = edgeType || EdgeType.NORMAL;\n\n\n  /**\n   * In-out transition for the sweepline crossing polygon\n   * @type {Boolean}\n   */\n  this.inOut = false;\n\n\n  /**\n   * @type {Boolean}\n   */\n  this.otherInOut = false;\n\n  /**\n   * Previous event in result?\n   * @type {SweepEvent}\n   */\n  this.prevInResult = null;\n\n  /**\n   * Does event belong to result?\n   * @type {Boolean}\n   */\n  this.inResult = false;\n\n\n  // connection step\n\n  /**\n   * @type {Boolean}\n   */\n  this.resultInOut = false;\n\n  this.isExteriorRing = true;\n}\n\n\nSweepEvent.prototype = {\n\n  /**\n   * @param  {Array.<Number>}  p\n   * @return {Boolean}\n   */\n  isBelow: function (p) {\n    var p0 = this.point, p1 = this.otherEvent.point;\n    return this.left ?\n      (p0[0] - p[0]) * (p1[1] - p[1]) - (p1[0] - p[0]) * (p0[1] - p[1]) > 0 :\n      // signedArea(this.point, this.otherEvent.point, p) > 0 :\n      (p1[0] - p[0]) * (p0[1] - p[1]) - (p0[0] - p[0]) * (p1[1] - p[1]) > 0;\n      //signedArea(this.otherEvent.point, this.point, p) > 0;\n  },\n\n\n  /**\n   * @param  {Array.<Number>}  p\n   * @return {Boolean}\n   */\n  isAbove: function (p) {\n    return !this.isBelow(p);\n  },\n\n\n  /**\n   * @return {Boolean}\n   */\n  isVertical: function () {\n    return this.point[0] === this.otherEvent.point[0];\n  },\n\n\n  clone: function () {\n    var copy = new SweepEvent(\n      this.point, this.left, this.otherEvent, this.isSubject, this.type);\n\n    copy.inResult       = this.inResult;\n    copy.prevInResult   = this.prevInResult;\n    copy.isExteriorRing = this.isExteriorRing;\n    copy.inOut          = this.inOut;\n    copy.otherInOut     = this.otherInOut;\n\n    return copy;\n  }\n};\n\nmodule.exports = SweepEvent;\n\n},{\"./edge_type\":9}]},{},[1])(1)\n});","'use strict';\n\nfunction _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }\n\nvar martinez = _interopDefault(require('martinez-polygon-clipping'));\nvar area = _interopDefault(require('@turf/area'));\nvar helpers = require('@turf/helpers');\nvar invariant = require('@turf/invariant');\nvar meta = require('@turf/meta');\n\n/**\n * Finds the difference between two {@link Polygon|polygons} by clipping the second polygon from the first.\n *\n * @name difference\n * @param {Feature<Polygon|MultiPolygon>} polygon1 input Polygon feature\n * @param {Feature<Polygon|MultiPolygon>} polygon2 Polygon feature to difference from polygon1\n * @returns {Feature<Polygon|MultiPolygon>|null} a Polygon or MultiPolygon feature showing the area of `polygon1` excluding the area of `polygon2` (if empty returns `null`)\n * @example\n * var polygon1 = turf.polygon([[\n *   [128, -26],\n *   [141, -26],\n *   [141, -21],\n *   [128, -21],\n *   [128, -26]\n * ]], {\n *   \"fill\": \"#F00\",\n *   \"fill-opacity\": 0.1\n * });\n * var polygon2 = turf.polygon([[\n *   [126, -28],\n *   [140, -28],\n *   [140, -20],\n *   [126, -20],\n *   [126, -28]\n * ]], {\n *   \"fill\": \"#00F\",\n *   \"fill-opacity\": 0.1\n * });\n *\n * var difference = turf.difference(polygon1, polygon2);\n *\n * //addToMap\n * var addToMap = [polygon1, polygon2, difference];\n */\nfunction difference(polygon1, polygon2) {\n    var geom1 = invariant.getGeom(polygon1);\n    var geom2 = invariant.getGeom(polygon2);\n    var properties = polygon1.properties || {};\n\n    // Issue #721 - JSTS/Martinez can't handle empty polygons\n    geom1 = removeEmptyPolygon(geom1);\n    geom2 = removeEmptyPolygon(geom2);\n    if (!geom1) return null;\n    if (!geom2) return helpers.feature(geom1, properties);\n\n    var differenced = martinez.diff(geom1.coordinates, geom2.coordinates);\n    if (differenced.length === 0) return null;\n    if (differenced.length === 1) return helpers.polygon(differenced[0], properties);\n    return helpers.multiPolygon(differenced, properties);\n}\n\n/**\n * Detect Empty Polygon\n *\n * @private\n * @param {Geometry<Polygon|MultiPolygon>} geom Geometry Object\n * @returns {Geometry<Polygon|MultiPolygon>|null} removed any polygons with no areas\n */\nfunction removeEmptyPolygon(geom) {\n    switch (geom.type) {\n    case 'Polygon':\n        if (area(geom) > 1) return geom;\n        return null;\n    case 'MultiPolygon':\n        var coordinates = [];\n        meta.flattenEach(geom, function (feature) {\n            if (area(feature) > 1) coordinates.push(feature.geometry.coordinates);\n        });\n        if (coordinates.length) return {type: 'MultiPolygon', coordinates: coordinates};\n    }\n}\n\nmodule.exports = difference;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar martinez = require(\"martinez-polygon-clipping\");\nvar invariant_1 = require(\"@turf/invariant\");\nvar helpers_1 = require(\"@turf/helpers\");\n/**\n * Takes two {@link (Multi)Polygon(s)} and returns a combined polygon. If the input polygons are not contiguous, this function returns a {@link MultiPolygon} feature.\n *\n * @name union\n * @param {Feature<Polygon|MultiPolygon>} polygon1 input Polygon feature\n * @param {Feature<Polygon|MultiPolygon>} polygon2 Polygon feature to difference from polygon1\n * @param {Object} [options={}] Optional Parameters\n * @param {Object} [options.properties={}] Translate Properties to output Feature\n * @returns {Feature<(Polygon|MultiPolygon)>} a combined {@link Polygon} or {@link MultiPolygon} feature\n * @example\n * var poly1 = turf.polygon([[\n *     [-82.574787, 35.594087],\n *     [-82.574787, 35.615581],\n *     [-82.545261, 35.615581],\n *     [-82.545261, 35.594087],\n *     [-82.574787, 35.594087]\n * ]], {\"fill\": \"#0f0\"});\n * var poly2 = turf.polygon([[\n *     [-82.560024, 35.585153],\n *     [-82.560024, 35.602602],\n *     [-82.52964, 35.602602],\n *     [-82.52964, 35.585153],\n *     [-82.560024, 35.585153]\n * ]], {\"fill\": \"#00f\"});\n *\n * var union = turf.union(poly1, poly2);\n *\n * //addToMap\n * var addToMap = [poly1, poly2, union];\n */\nfunction union(polygon1, polygon2, options) {\n    if (options === void 0) { options = {}; }\n    var coords1 = invariant_1.getGeom(polygon1).coordinates;\n    var coords2 = invariant_1.getGeom(polygon2).coordinates;\n    var unioned = martinez.union(coords1, coords2);\n    if (unioned.length === 0)\n        return null;\n    if (unioned.length === 1)\n        return helpers_1.polygon(unioned[0], options.properties);\n    else\n        return helpers_1.multiPolygon(unioned, options.properties);\n}\nexports.default = union;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar destination_1 = require(\"@turf/destination\");\nvar helpers_1 = require(\"@turf/helpers\");\n/**\n * Takes a {@link Point} and calculates the circle polygon given a radius in degrees, radians, miles, or kilometers; and steps for precision.\n *\n * @name circle\n * @param {Feature<Point>|number[]} center center point\n * @param {number} radius radius of the circle\n * @param {Object} [options={}] Optional parameters\n * @param {number} [options.steps=64] number of steps\n * @param {string} [options.units='kilometers'] miles, kilometers, degrees, or radians\n * @param {Object} [options.properties={}] properties\n * @returns {Feature<Polygon>} circle polygon\n * @example\n * var center = [-75.343, 39.984];\n * var radius = 5;\n * var options = {steps: 10, units: 'kilometers', properties: {foo: 'bar'}};\n * var circle = turf.circle(center, radius, options);\n *\n * //addToMap\n * var addToMap = [turf.point(center), circle]\n */\nfunction circle(center, radius, options) {\n    if (options === void 0) { options = {}; }\n    // default params\n    var steps = options.steps || 64;\n    var properties = options.properties ? options.properties : (!Array.isArray(center) && center.type === 'Feature' && center.properties) ? center.properties : {};\n    // main\n    var coordinates = [];\n    for (var i = 0; i < steps; i++) {\n        coordinates.push(destination_1.default(center, radius, i * -360 / steps, options).geometry.coordinates);\n    }\n    coordinates.push(coordinates[0]);\n    return helpers_1.polygon([coordinates], properties);\n}\nexports.default = circle;\n","import circle from '@turf/circle';\nimport union from '@turf/union';\nimport difference from '@turf/difference';\n\n\nlet turf = {\n\tcircle: circle,\n\tunion: union,\n\tdifference: difference\n};\n\nexport default turf;","//import L from 'leaflet';\nimport turf from './myTurf.js';\nimport './PaintPolygon.css';\n\n\"use strict\";\n\n\nconst PaintPolygon = L.Control.extend({\n    options: {\n        position: 'topright',\n        radius: 30,\n        minRadius: 10,\n        maxRadius: 50,\n        layerOptions: {\n        },\n        drawOptions: {\n            weight: 1\n        },\n        eraseOptions: {\n            color: '#ff324a',\n            weight: 1\n        },\n        menu: {\n            drawErase: true,\n            size: true,\n            eraseAll: true\n        },\n    },\n\n    _latlng: [0, 0],\n    _metersPerPixel: {},\n\n    onAdd: function(map) {\n        this._map = map;\n        this.setRadius(this.options.radius);\n\n        if (this.options.menu === false) {\n            return L.DomUtil.create('div');\n        }\n\n        this._container = L.DomUtil.create('div', 'leaflet-control-paintpolygon leaflet-bar leaflet-control');\n        this._createMenu();\n\n        return this._container;\n    },\n\n    onRemove: function() {\n        this._map.off('mousemove', this._onMouseMove, this);\n    },\n\n    setRadius: function(radius) {\n        if (radius !== undefined) {\n            if (radius < this.options.minRadius) {\n                this._radius = this.options.minRadius;\n            } else if (radius > this.options.maxRadius) {\n                this._radius = this.options.maxRadius;\n            } else {\n                this._radius = radius;\n            }\n        }\n        if (this._circle) {\n            this._circle.setRadius(this._radius);\n        }\n    },\n    startDraw: function() {\n        this.stop();\n        this._action = 'draw';\n        this._addMouseListener();\n        this._circle = L.circleMarker(this._latlng, this.options.drawOptions).setRadius(this._radius).addTo(this._map);\n    },\n    startErase: function() {\n        this.stop();\n        this._action = 'erase';\n        this._addMouseListener();\n        this._circle = L.circleMarker(this._latlng, this.options.eraseOptions).setRadius(this._radius).addTo(this._map);\n    },\n    stop: function() {\n        this._action = null;\n        if (this._circle) {\n            this._circle.remove();\n        }\n        this._removeMouseListener();\n    },\n    getLayer: function() {\n        return this._layer;\n    },\n    setData: function(data) {\n        this._data = data;\n        if (this._layer !== undefined) {\n            this._layer.remove();\n        }\n        this._layer = L.geoJSON(this._data, this.options.layerOptions).addTo(this._map);\n    },\n    getData: function() {\n        return this._data;\n    },\n    eraseAll: function() {\n        this.setData();\n    },\n\n    /////////////////////////\n    // Menu creation and click callback\n    _createMenu: function() {\n        if (this.options.menu.drawErase !== false) {\n            this._iconDraw = L.DomUtil.create('a', 'leaflet-control-paintpolygon-icon leaflet-control-paintpolygon-icon-brush', this._container);\n            this._iconErase = L.DomUtil.create('a', 'leaflet-control-paintpolygon-icon leaflet-control-paintpolygon-icon-eraser', this._container);\n            L.DomEvent.on(this._iconDraw, 'click mousedown', this._clickDraw, this);\n            L.DomEvent.on(this._iconErase, 'click mousedown', this._clickErase, this);\n        }\n\n        if (this.options.menu.size !== false) {\n            this._iconSize = L.DomUtil.create('a', 'leaflet-control-paintpolygon-icon leaflet-control-paintpolygon-icon-size', this._container);\n\n            this._menu = L.DomUtil.create('div', 'leaflet-bar leaflet-control-paintpolygon-menu', this._container);\n            L.DomEvent.disableClickPropagation(this._menu);\n\n            var menuContent = L.DomUtil.create('div', 'leaflet-control-paintpolygon-menu-content', this._menu);\n            var cursor = L.DomUtil.create('input', '', menuContent);\n            cursor.type = \"range\";\n            cursor.value = this._radius;\n            cursor.min = this.options.minRadius;\n            cursor.max = this.options.maxRadius;\n\n            L.DomEvent.on(cursor, 'input change', this._cursorMove, this);\n            L.DomEvent.on(this._iconSize, 'click mousedown', this._clickSize, this);\n        }\n\n        if (this.options.menu.eraseAll !== false) {\n            this._iconEraseAll = L.DomUtil.create('a', 'leaflet-control-paintpolygon-icon leaflet-control-paintpolygon-icon-trash', this._container);\n            L.DomEvent.on(this._iconEraseAll, 'click mousedown', this._clickEraseAll, this);\n        }\n    },\n\n    _clickDraw: function(evt) {\n        if (evt.type == 'mousedown') {\n            L.DomEvent.stop(evt);\n            return;\n        }\n        this._resetMenu();\n        if (this._action == 'draw') {\n            this.stop();\n        } else {\n            this.startDraw();\n            this._activeIconStyle(this._iconDraw);\n        }\n    },\n    _clickErase: function(evt) {\n        if (evt.type == 'mousedown') {\n            L.DomEvent.stop(evt);\n            return;\n        }\n        this._resetMenu();\n        if (this._action == 'erase') {\n            this.stop();\n        } else {\n            this.startErase();\n            this._activeIconStyle(this._iconErase);\n        }\n    },\n    _clickSize: function(evt) {\n        if (evt.type == 'mousedown') {\n            L.DomEvent.stop(evt);\n            return;\n        }\n        if (L.DomUtil.hasClass(this._menu, 'leaflet-control-paintpolygon-menu-open')) {\n            this._closeMenu();\n        } else {\n            this._openMenu();\n        }\n    },\n    _clickEraseAll: function(evt) {\n        this.eraseAll();\n    },\n    _resetMenu: function() {\n        L.DomUtil.removeClass(this._iconDraw, \"leaflet-control-paintpolygon-icon-active\");\n        L.DomUtil.removeClass(this._iconErase, \"leaflet-control-paintpolygon-icon-active\");\n    },\n    _activeIconStyle: function(icon) {\n        L.DomUtil.addClass(icon, \"leaflet-control-paintpolygon-icon-active\");\n    },\n    _openMenu: function() {\n        L.DomUtil.addClass(this._menu, \"leaflet-control-paintpolygon-menu-open\");\n    },\n    _closeMenu: function() {\n        L.DomUtil.removeClass(this._menu, \"leaflet-control-paintpolygon-menu-open\");\n    },\n    _cursorMove: function(evt) {\n        this.setRadius(evt.target.valueAsNumber);\n    },\n    /////////////////\n\n\n\n    ////////////////\n    // Map events\n    _addMouseListener: function() {\n        this._map.on('mousemove', this._onMouseMove, this);\n        this._map.on('mousedown', this._onMouseDown, this);\n        this._map.on('mouseup', this._onMouseUp, this);\n    },\n    _removeMouseListener: function() {\n        this._map.off('mousemove', this._onMouseMove, this);\n        this._map.off('mousedown', this._onMouseDown, this);\n        this._map.off('mouseup', this._onMouseUp, this);\n    },\n    _onMouseDown: function(evt) {\n        this._map.dragging.disable();\n        this._mousedown = true;\n        this._onMouseMove(evt);\n    },\n    _onMouseUp: function(evt) {\n        this._map.dragging.enable();\n        this._mousedown = false;\n    },\n    _onMouseMove: function(evt) {\n        this._setLatLng(evt.latlng);\n        if (this._mousedown === true) {\n            this._stackEvt(evt.latlng, this._map.getZoom(), this._radius, this._action);\n        }\n    },\n    ////////////////\n\n    _setLatLng: function(latlng) {\n        if (latlng !== undefined) {\n            this._latlng = latlng;\n        }\n        if (this._circle) {\n            this._circle.setLatLng(this._latlng);\n        }\n    },\n\n    _latLngAsGeoJSON: function(latlng) {\n        return {\n            type: \"Point\",\n            coordinates: [\n                latlng.lng,\n                latlng.lat\n            ]\n        };\n    },\n\n    _getCircleAsPolygon: function(latlng, zoom, radius) {\n        var lat = latlng.lat;\n\n        if (this._metersPerPixel[zoom] === undefined){\n            this._metersPerPixel[zoom] = 40075016.686 * Math.abs(Math.cos(lat * Math.PI / 180)) / Math.pow(2, zoom + 8);\n        }\n        return turf.circle(this._latLngAsGeoJSON(latlng), this._metersPerPixel[zoom] * radius / 1000, {\n            //steps: 128\n        });\n    },\n\n    _draw: function(latlng, zoom, radius) {\n        if (this._data === undefined || this._data === null) {\n            this.setData(this._getCircleAsPolygon(latlng, zoom, radius));\n        } else {\n            this.setData(turf.union(this._data, this._getCircleAsPolygon(latlng, zoom, radius)));\n        }\n    },\n    _erase: function(latlng, zoom, radius) {\n        if (this._data === undefined || this._data === null) {\n            return;\n        } else {\n            this.setData(turf.difference(this._data, this._getCircleAsPolygon(latlng, zoom, radius)));\n        }\n    },\n\n    _stackEvt: function(latlng, zoom, radius, action) {\n        if (this._stack === undefined){\n            this._stack = new Array();\n        }\n\n        this._stack.push({latlng: latlng, zoom: zoom, radius: radius, action: action});\n        this._processStack();\n    },\n\n    _processStack: function() {\n        if (this._processingStack === true || this._stack.length == 0){\n            return;\n        }\n        this._processingStack = true;\n\n        var evt = this._stack.shift();\n        if (evt.action == \"draw\"){\n            this._draw(evt.latlng, evt.zoom, evt.radius);\n        } else if (evt.action == \"erase\") {\n            this._erase(evt.latlng, evt.zoom, evt.radius);\n        }\n\n        this._processingStack = false;\n        this._processStack();\n    }\n \n});\n\n\nL.Control.PaintPolygon = PaintPolygon;\nL.control.paintPolygon = options => new L.Control.PaintPolygon(options);\n\n\nexport default PaintPolygon;\n","\n/**\n * When source maps are enabled, `style-loader` uses a link element with a data-uri to\n * embed the css on the page. This breaks all relative urls because now they are relative to a\n * bundle instead of the current page.\n *\n * One solution is to only use full urls, but that may be impossible.\n *\n * Instead, this function \"fixes\" the relative urls to be absolute according to the current page location.\n *\n * A rudimentary test suite is located at `test/fixUrls.js` and can be run via the `npm test` command.\n *\n */\n\nmodule.exports = function (css) {\n  // get current location\n  var location = typeof window !== \"undefined\" && window.location;\n\n  if (!location) {\n    throw new Error(\"fixUrls requires window.location\");\n  }\n\n\t// blank or null?\n\tif (!css || typeof css !== \"string\") {\n\t  return css;\n  }\n\n  var baseUrl = location.protocol + \"//\" + location.host;\n  var currentDir = baseUrl + location.pathname.replace(/\\/[^\\/]*$/, \"/\");\n\n\t// convert each url(...)\n\t/*\n\tThis regular expression is just a way to recursively match brackets within\n\ta string.\n\n\t /url\\s*\\(  = Match on the word \"url\" with any whitespace after it and then a parens\n\t   (  = Start a capturing group\n\t     (?:  = Start a non-capturing group\n\t         [^)(]  = Match anything that isn't a parentheses\n\t         |  = OR\n\t         \\(  = Match a start parentheses\n\t             (?:  = Start another non-capturing groups\n\t                 [^)(]+  = Match anything that isn't a parentheses\n\t                 |  = OR\n\t                 \\(  = Match a start parentheses\n\t                     [^)(]*  = Match anything that isn't a parentheses\n\t                 \\)  = Match a end parentheses\n\t             )  = End Group\n              *\\) = Match anything and then a close parens\n          )  = Close non-capturing group\n          *  = Match anything\n       )  = Close capturing group\n\t \\)  = Match a close parens\n\n\t /gi  = Get all matches, not the first.  Be case insensitive.\n\t */\n\tvar fixedCss = css.replace(/url\\s*\\(((?:[^)(]|\\((?:[^)(]+|\\([^)(]*\\))*\\))*)\\)/gi, function(fullMatch, origUrl) {\n\t\t// strip quotes (if they exist)\n\t\tvar unquotedOrigUrl = origUrl\n\t\t\t.trim()\n\t\t\t.replace(/^\"(.*)\"$/, function(o, $1){ return $1; })\n\t\t\t.replace(/^'(.*)'$/, function(o, $1){ return $1; });\n\n\t\t// already a full url? no change\n\t\tif (/^(#|data:|http:\\/\\/|https:\\/\\/|file:\\/\\/\\/|\\s*$)/i.test(unquotedOrigUrl)) {\n\t\t  return fullMatch;\n\t\t}\n\n\t\t// convert the url to a full url\n\t\tvar newUrl;\n\n\t\tif (unquotedOrigUrl.indexOf(\"//\") === 0) {\n\t\t  \t//TODO: should we add protocol?\n\t\t\tnewUrl = unquotedOrigUrl;\n\t\t} else if (unquotedOrigUrl.indexOf(\"/\") === 0) {\n\t\t\t// path should be relative to the base url\n\t\t\tnewUrl = baseUrl + unquotedOrigUrl; // already starts with '/'\n\t\t} else {\n\t\t\t// path should be relative to current directory\n\t\t\tnewUrl = currentDir + unquotedOrigUrl.replace(/^\\.\\//, \"\"); // Strip leading './'\n\t\t}\n\n\t\t// send back the fixed url(...)\n\t\treturn \"url(\" + JSON.stringify(newUrl) + \")\";\n\t});\n\n\t// send back the fixed css\n\treturn fixedCss;\n};\n","/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\nvar stylesInDom = {};\n\nvar\tmemoize = function (fn) {\n\tvar memo;\n\n\treturn function () {\n\t\tif (typeof memo === \"undefined\") memo = fn.apply(this, arguments);\n\t\treturn memo;\n\t};\n};\n\nvar isOldIE = memoize(function () {\n\t// Test for IE <= 9 as proposed by Browserhacks\n\t// @see http://browserhacks.com/#hack-e71d8692f65334173fee715c222cb805\n\t// Tests for existence of standard globals is to allow style-loader\n\t// to operate correctly into non-standard environments\n\t// @see https://github.com/webpack-contrib/style-loader/issues/177\n\treturn window && document && document.all && !window.atob;\n});\n\nvar getTarget = function (target) {\n  return document.querySelector(target);\n};\n\nvar getElement = (function (fn) {\n\tvar memo = {};\n\n\treturn function(target) {\n                // If passing function in options, then use it for resolve \"head\" element.\n                // Useful for Shadow Root style i.e\n                // {\n                //   insertInto: function () { return document.querySelector(\"#foo\").shadowRoot }\n                // }\n                if (typeof target === 'function') {\n                        return target();\n                }\n                if (typeof memo[target] === \"undefined\") {\n\t\t\tvar styleTarget = getTarget.call(this, target);\n\t\t\t// Special case to return head of iframe instead of iframe itself\n\t\t\tif (window.HTMLIFrameElement && styleTarget instanceof window.HTMLIFrameElement) {\n\t\t\t\ttry {\n\t\t\t\t\t// This will throw an exception if access to iframe is blocked\n\t\t\t\t\t// due to cross-origin restrictions\n\t\t\t\t\tstyleTarget = styleTarget.contentDocument.head;\n\t\t\t\t} catch(e) {\n\t\t\t\t\tstyleTarget = null;\n\t\t\t\t}\n\t\t\t}\n\t\t\tmemo[target] = styleTarget;\n\t\t}\n\t\treturn memo[target]\n\t};\n})();\n\nvar singleton = null;\nvar\tsingletonCounter = 0;\nvar\tstylesInsertedAtTop = [];\n\nvar\tfixUrls = require(\"./urls\");\n\nmodule.exports = function(list, options) {\n\tif (typeof DEBUG !== \"undefined\" && DEBUG) {\n\t\tif (typeof document !== \"object\") throw new Error(\"The style-loader cannot be used in a non-browser environment\");\n\t}\n\n\toptions = options || {};\n\n\toptions.attrs = typeof options.attrs === \"object\" ? options.attrs : {};\n\n\t// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>\n\t// tags it will allow on a page\n\tif (!options.singleton && typeof options.singleton !== \"boolean\") options.singleton = isOldIE();\n\n\t// By default, add <style> tags to the <head> element\n        if (!options.insertInto) options.insertInto = \"head\";\n\n\t// By default, add <style> tags to the bottom of the target\n\tif (!options.insertAt) options.insertAt = \"bottom\";\n\n\tvar styles = listToStyles(list, options);\n\n\taddStylesToDom(styles, options);\n\n\treturn function update (newList) {\n\t\tvar mayRemove = [];\n\n\t\tfor (var i = 0; i < styles.length; i++) {\n\t\t\tvar item = styles[i];\n\t\t\tvar domStyle = stylesInDom[item.id];\n\n\t\t\tdomStyle.refs--;\n\t\t\tmayRemove.push(domStyle);\n\t\t}\n\n\t\tif(newList) {\n\t\t\tvar newStyles = listToStyles(newList, options);\n\t\t\taddStylesToDom(newStyles, options);\n\t\t}\n\n\t\tfor (var i = 0; i < mayRemove.length; i++) {\n\t\t\tvar domStyle = mayRemove[i];\n\n\t\t\tif(domStyle.refs === 0) {\n\t\t\t\tfor (var j = 0; j < domStyle.parts.length; j++) domStyle.parts[j]();\n\n\t\t\t\tdelete stylesInDom[domStyle.id];\n\t\t\t}\n\t\t}\n\t};\n};\n\nfunction addStylesToDom (styles, options) {\n\tfor (var i = 0; i < styles.length; i++) {\n\t\tvar item = styles[i];\n\t\tvar domStyle = stylesInDom[item.id];\n\n\t\tif(domStyle) {\n\t\t\tdomStyle.refs++;\n\n\t\t\tfor(var j = 0; j < domStyle.parts.length; j++) {\n\t\t\t\tdomStyle.parts[j](item.parts[j]);\n\t\t\t}\n\n\t\t\tfor(; j < item.parts.length; j++) {\n\t\t\t\tdomStyle.parts.push(addStyle(item.parts[j], options));\n\t\t\t}\n\t\t} else {\n\t\t\tvar parts = [];\n\n\t\t\tfor(var j = 0; j < item.parts.length; j++) {\n\t\t\t\tparts.push(addStyle(item.parts[j], options));\n\t\t\t}\n\n\t\t\tstylesInDom[item.id] = {id: item.id, refs: 1, parts: parts};\n\t\t}\n\t}\n}\n\nfunction listToStyles (list, options) {\n\tvar styles = [];\n\tvar newStyles = {};\n\n\tfor (var i = 0; i < list.length; i++) {\n\t\tvar item = list[i];\n\t\tvar id = options.base ? item[0] + options.base : item[0];\n\t\tvar css = item[1];\n\t\tvar media = item[2];\n\t\tvar sourceMap = item[3];\n\t\tvar part = {css: css, media: media, sourceMap: sourceMap};\n\n\t\tif(!newStyles[id]) styles.push(newStyles[id] = {id: id, parts: [part]});\n\t\telse newStyles[id].parts.push(part);\n\t}\n\n\treturn styles;\n}\n\nfunction insertStyleElement (options, style) {\n\tvar target = getElement(options.insertInto)\n\n\tif (!target) {\n\t\tthrow new Error(\"Couldn't find a style target. This probably means that the value for the 'insertInto' parameter is invalid.\");\n\t}\n\n\tvar lastStyleElementInsertedAtTop = stylesInsertedAtTop[stylesInsertedAtTop.length - 1];\n\n\tif (options.insertAt === \"top\") {\n\t\tif (!lastStyleElementInsertedAtTop) {\n\t\t\ttarget.insertBefore(style, target.firstChild);\n\t\t} else if (lastStyleElementInsertedAtTop.nextSibling) {\n\t\t\ttarget.insertBefore(style, lastStyleElementInsertedAtTop.nextSibling);\n\t\t} else {\n\t\t\ttarget.appendChild(style);\n\t\t}\n\t\tstylesInsertedAtTop.push(style);\n\t} else if (options.insertAt === \"bottom\") {\n\t\ttarget.appendChild(style);\n\t} else if (typeof options.insertAt === \"object\" && options.insertAt.before) {\n\t\tvar nextSibling = getElement(options.insertInto + \" \" + options.insertAt.before);\n\t\ttarget.insertBefore(style, nextSibling);\n\t} else {\n\t\tthrow new Error(\"[Style Loader]\\n\\n Invalid value for parameter 'insertAt' ('options.insertAt') found.\\n Must be 'top', 'bottom', or Object.\\n (https://github.com/webpack-contrib/style-loader#insertat)\\n\");\n\t}\n}\n\nfunction removeStyleElement (style) {\n\tif (style.parentNode === null) return false;\n\tstyle.parentNode.removeChild(style);\n\n\tvar idx = stylesInsertedAtTop.indexOf(style);\n\tif(idx >= 0) {\n\t\tstylesInsertedAtTop.splice(idx, 1);\n\t}\n}\n\nfunction createStyleElement (options) {\n\tvar style = document.createElement(\"style\");\n\n\tif(options.attrs.type === undefined) {\n\t\toptions.attrs.type = \"text/css\";\n\t}\n\n\taddAttrs(style, options.attrs);\n\tinsertStyleElement(options, style);\n\n\treturn style;\n}\n\nfunction createLinkElement (options) {\n\tvar link = document.createElement(\"link\");\n\n\tif(options.attrs.type === undefined) {\n\t\toptions.attrs.type = \"text/css\";\n\t}\n\toptions.attrs.rel = \"stylesheet\";\n\n\taddAttrs(link, options.attrs);\n\tinsertStyleElement(options, link);\n\n\treturn link;\n}\n\nfunction addAttrs (el, attrs) {\n\tObject.keys(attrs).forEach(function (key) {\n\t\tel.setAttribute(key, attrs[key]);\n\t});\n}\n\nfunction addStyle (obj, options) {\n\tvar style, update, remove, result;\n\n\t// If a transform function was defined, run it on the css\n\tif (options.transform && obj.css) {\n\t    result = options.transform(obj.css);\n\n\t    if (result) {\n\t    \t// If transform returns a value, use that instead of the original css.\n\t    \t// This allows running runtime transformations on the css.\n\t    \tobj.css = result;\n\t    } else {\n\t    \t// If the transform function returns a falsy value, don't add this css.\n\t    \t// This allows conditional loading of css\n\t    \treturn function() {\n\t    \t\t// noop\n\t    \t};\n\t    }\n\t}\n\n\tif (options.singleton) {\n\t\tvar styleIndex = singletonCounter++;\n\n\t\tstyle = singleton || (singleton = createStyleElement(options));\n\n\t\tupdate = applyToSingletonTag.bind(null, style, styleIndex, false);\n\t\tremove = applyToSingletonTag.bind(null, style, styleIndex, true);\n\n\t} else if (\n\t\tobj.sourceMap &&\n\t\ttypeof URL === \"function\" &&\n\t\ttypeof URL.createObjectURL === \"function\" &&\n\t\ttypeof URL.revokeObjectURL === \"function\" &&\n\t\ttypeof Blob === \"function\" &&\n\t\ttypeof btoa === \"function\"\n\t) {\n\t\tstyle = createLinkElement(options);\n\t\tupdate = updateLink.bind(null, style, options);\n\t\tremove = function () {\n\t\t\tremoveStyleElement(style);\n\n\t\t\tif(style.href) URL.revokeObjectURL(style.href);\n\t\t};\n\t} else {\n\t\tstyle = createStyleElement(options);\n\t\tupdate = applyToTag.bind(null, style);\n\t\tremove = function () {\n\t\t\tremoveStyleElement(style);\n\t\t};\n\t}\n\n\tupdate(obj);\n\n\treturn function updateStyle (newObj) {\n\t\tif (newObj) {\n\t\t\tif (\n\t\t\t\tnewObj.css === obj.css &&\n\t\t\t\tnewObj.media === obj.media &&\n\t\t\t\tnewObj.sourceMap === obj.sourceMap\n\t\t\t) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tupdate(obj = newObj);\n\t\t} else {\n\t\t\tremove();\n\t\t}\n\t};\n}\n\nvar replaceText = (function () {\n\tvar textStore = [];\n\n\treturn function (index, replacement) {\n\t\ttextStore[index] = replacement;\n\n\t\treturn textStore.filter(Boolean).join('\\n');\n\t};\n})();\n\nfunction applyToSingletonTag (style, index, remove, obj) {\n\tvar css = remove ? \"\" : obj.css;\n\n\tif (style.styleSheet) {\n\t\tstyle.styleSheet.cssText = replaceText(index, css);\n\t} else {\n\t\tvar cssNode = document.createTextNode(css);\n\t\tvar childNodes = style.childNodes;\n\n\t\tif (childNodes[index]) style.removeChild(childNodes[index]);\n\n\t\tif (childNodes.length) {\n\t\t\tstyle.insertBefore(cssNode, childNodes[index]);\n\t\t} else {\n\t\t\tstyle.appendChild(cssNode);\n\t\t}\n\t}\n}\n\nfunction applyToTag (style, obj) {\n\tvar css = obj.css;\n\tvar media = obj.media;\n\n\tif(media) {\n\t\tstyle.setAttribute(\"media\", media)\n\t}\n\n\tif(style.styleSheet) {\n\t\tstyle.styleSheet.cssText = css;\n\t} else {\n\t\twhile(style.firstChild) {\n\t\t\tstyle.removeChild(style.firstChild);\n\t\t}\n\n\t\tstyle.appendChild(document.createTextNode(css));\n\t}\n}\n\nfunction updateLink (link, options, obj) {\n\tvar css = obj.css;\n\tvar sourceMap = obj.sourceMap;\n\n\t/*\n\t\tIf convertToAbsoluteUrls isn't defined, but sourcemaps are enabled\n\t\tand there is no publicPath defined then lets turn convertToAbsoluteUrls\n\t\ton by default.  Otherwise default to the convertToAbsoluteUrls option\n\t\tdirectly\n\t*/\n\tvar autoFixUrls = options.convertToAbsoluteUrls === undefined && sourceMap;\n\n\tif (options.convertToAbsoluteUrls || autoFixUrls) {\n\t\tcss = fixUrls(css);\n\t}\n\n\tif (sourceMap) {\n\t\t// http://stackoverflow.com/a/26603875\n\t\tcss += \"\\n/*# sourceMappingURL=data:application/json;base64,\" + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + \" */\";\n\t}\n\n\tvar blob = new Blob([css], { type: \"text/css\" });\n\n\tvar oldSrc = link.href;\n\n\tlink.href = URL.createObjectURL(blob);\n\n\tif(oldSrc) URL.revokeObjectURL(oldSrc);\n}\n","module.exports = \"data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9Im5vIj8+CjwhLS0gQ3JlYXRlZCB3aXRoIElua3NjYXBlIChodHRwOi8vd3d3Lmlua3NjYXBlLm9yZy8pIC0tPgoKPHN2ZwogICB4bWxuczpkYz0iaHR0cDovL3B1cmwub3JnL2RjL2VsZW1lbnRzLzEuMS8iCiAgIHhtbG5zOmNjPSJodHRwOi8vY3JlYXRpdmVjb21tb25zLm9yZy9ucyMiCiAgIHhtbG5zOnJkZj0iaHR0cDovL3d3dy53My5vcmcvMTk5OS8wMi8yMi1yZGYtc3ludGF4LW5zIyIKICAgeG1sbnM6c3ZnPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIKICAgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIgogICB4bWxuczpzb2RpcG9kaT0iaHR0cDovL3NvZGlwb2RpLnNvdXJjZWZvcmdlLm5ldC9EVEQvc29kaXBvZGktMC5kdGQiCiAgIHhtbG5zOmlua3NjYXBlPSJodHRwOi8vd3d3Lmlua3NjYXBlLm9yZy9uYW1lc3BhY2VzL2lua3NjYXBlIgogICB3aWR0aD0iMzAiCiAgIGhlaWdodD0iMTIwIgogICB2aWV3Qm94PSIwIDAgNy45Mzc1IDMxLjc1MDAwMSIKICAgdmVyc2lvbj0iMS4xIgogICBpZD0ic3ZnOCIKICAgaW5rc2NhcGU6dmVyc2lvbj0iMC45Mi4zICgyNDA1NTQ2LCAyMDE4LTAzLTExKSIKICAgc29kaXBvZGk6ZG9jbmFtZT0iUGFpbnRQb2x5Z29uLnN2ZyI+CiAgPGRlZnMKICAgICBpZD0iZGVmczIiPgogICAgPG1hcmtlcgogICAgICAgaW5rc2NhcGU6c3RvY2tpZD0iQXJyb3cxU3N0YXJ0IgogICAgICAgb3JpZW50PSJhdXRvIgogICAgICAgcmVmWT0iMCIKICAgICAgIHJlZlg9IjAiCiAgICAgICBpZD0iQXJyb3cxU3N0YXJ0IgogICAgICAgc3R5bGU9Im92ZXJmbG93OnZpc2libGUiCiAgICAgICBpbmtzY2FwZTppc3N0b2NrPSJ0cnVlIj4KICAgICAgPHBhdGgKICAgICAgICAgaWQ9InBhdGg5NzMiCiAgICAgICAgIGQ9Ik0gMCwwIDUsLTUgLTEyLjUsMCA1LDUgWiIKICAgICAgICAgc3R5bGU9ImZpbGw6IzAwMDAwMDtmaWxsLW9wYWNpdHk6MTtmaWxsLXJ1bGU6ZXZlbm9kZDtzdHJva2U6IzAwMDAwMDtzdHJva2Utd2lkdGg6MS4wMDAwMDAwM3B0O3N0cm9rZS1vcGFjaXR5OjEiCiAgICAgICAgIHRyYW5zZm9ybT0ibWF0cml4KDAuMiwwLDAsMC4yLDEuMiwwKSIKICAgICAgICAgaW5rc2NhcGU6Y29ubmVjdG9yLWN1cnZhdHVyZT0iMCIgLz4KICAgIDwvbWFya2VyPgogICAgPG1hcmtlcgogICAgICAgaW5rc2NhcGU6c3RvY2tpZD0iQXJyb3cxTWVuZCIKICAgICAgIG9yaWVudD0iYXV0byIKICAgICAgIHJlZlk9IjAiCiAgICAgICByZWZYPSIwIgogICAgICAgaWQ9Im1hcmtlcjE1MjMiCiAgICAgICBzdHlsZT0ib3ZlcmZsb3c6dmlzaWJsZSIKICAgICAgIGlua3NjYXBlOmlzc3RvY2s9InRydWUiPgogICAgICA8cGF0aAogICAgICAgICBpZD0icGF0aDE1MjEiCiAgICAgICAgIGQ9Ik0gMCwwIDUsLTUgLTEyLjUsMCA1LDUgWiIKICAgICAgICAgc3R5bGU9ImZpbGw6IzAwMDAwMDtmaWxsLW9wYWNpdHk6MTtmaWxsLXJ1bGU6ZXZlbm9kZDtzdHJva2U6IzAwMDAwMDtzdHJva2Utd2lkdGg6MS4wMDAwMDAwM3B0O3N0cm9rZS1vcGFjaXR5OjEiCiAgICAgICAgIHRyYW5zZm9ybT0ibWF0cml4KC0wLjQsMCwwLC0wLjQsLTQsMCkiCiAgICAgICAgIGlua3NjYXBlOmNvbm5lY3Rvci1jdXJ2YXR1cmU9IjAiIC8+CiAgICA8L21hcmtlcj4KICAgIDxtYXJrZXIKICAgICAgIGlua3NjYXBlOnN0b2NraWQ9IkFycm93MkxlbmQiCiAgICAgICBvcmllbnQ9ImF1dG8iCiAgICAgICByZWZZPSIwIgogICAgICAgcmVmWD0iMCIKICAgICAgIGlkPSJBcnJvdzJMZW5kIgogICAgICAgc3R5bGU9Im92ZXJmbG93OnZpc2libGUiCiAgICAgICBpbmtzY2FwZTppc3N0b2NrPSJ0cnVlIj4KICAgICAgPHBhdGgKICAgICAgICAgaWQ9InBhdGg5ODIiCiAgICAgICAgIHN0eWxlPSJmaWxsOiMwMDAwMDA7ZmlsbC1vcGFjaXR5OjE7ZmlsbC1ydWxlOmV2ZW5vZGQ7c3Ryb2tlOiMwMDAwMDA7c3Ryb2tlLXdpZHRoOjAuNjI1O3N0cm9rZS1saW5lam9pbjpyb3VuZDtzdHJva2Utb3BhY2l0eToxIgogICAgICAgICBkPSJNIDguNzE4NTg3OCw0LjAzMzczNTIgLTIuMjA3Mjg5NSwwLjAxNjAxMzI2IDguNzE4NTg4NCwtNC4wMDE3MDc4IGMgLTEuNzQ1NDk4NCwyLjM3MjA2MDkgLTEuNzM1NDQwOCw1LjYxNzQ1MTkgLTZlLTcsOC4wMzU0NDMgeiIKICAgICAgICAgdHJhbnNmb3JtPSJtYXRyaXgoLTEuMSwwLDAsLTEuMSwtMS4xLDApIgogICAgICAgICBpbmtzY2FwZTpjb25uZWN0b3ItY3VydmF0dXJlPSIwIiAvPgogICAgPC9tYXJrZXI+CiAgICA8bWFya2VyCiAgICAgICBpbmtzY2FwZTpzdG9ja2lkPSJBcnJvdzFMZW5kIgogICAgICAgb3JpZW50PSJhdXRvIgogICAgICAgcmVmWT0iMCIKICAgICAgIHJlZlg9IjAiCiAgICAgICBpZD0iQXJyb3cxTGVuZCIKICAgICAgIHN0eWxlPSJvdmVyZmxvdzp2aXNpYmxlIgogICAgICAgaW5rc2NhcGU6aXNzdG9jaz0idHJ1ZSI+CiAgICAgIDxwYXRoCiAgICAgICAgIGlkPSJwYXRoOTY0IgogICAgICAgICBkPSJNIDAsMCA1LC01IC0xMi41LDAgNSw1IFoiCiAgICAgICAgIHN0eWxlPSJmaWxsOiMwMDAwMDA7ZmlsbC1vcGFjaXR5OjE7ZmlsbC1ydWxlOmV2ZW5vZGQ7c3Ryb2tlOiMwMDAwMDA7c3Ryb2tlLXdpZHRoOjEuMDAwMDAwMDNwdDtzdHJva2Utb3BhY2l0eToxIgogICAgICAgICB0cmFuc2Zvcm09Im1hdHJpeCgtMC44LDAsMCwtMC44LC0xMCwwKSIKICAgICAgICAgaW5rc2NhcGU6Y29ubmVjdG9yLWN1cnZhdHVyZT0iMCIgLz4KICAgIDwvbWFya2VyPgogICAgPG1hcmtlcgogICAgICAgaW5rc2NhcGU6c3RvY2tpZD0iQXJyb3cxTHN0YXJ0IgogICAgICAgb3JpZW50PSJhdXRvIgogICAgICAgcmVmWT0iMCIKICAgICAgIHJlZlg9IjAiCiAgICAgICBpZD0ibWFya2VyMTI5NSIKICAgICAgIHN0eWxlPSJvdmVyZmxvdzp2aXNpYmxlIgogICAgICAgaW5rc2NhcGU6aXNzdG9jaz0idHJ1ZSI+CiAgICAgIDxwYXRoCiAgICAgICAgIGlkPSJwYXRoMTI5MyIKICAgICAgICAgZD0iTSAwLDAgNSwtNSAtMTIuNSwwIDUsNSBaIgogICAgICAgICBzdHlsZT0iZmlsbDojMDAwMDAwO2ZpbGwtb3BhY2l0eToxO2ZpbGwtcnVsZTpldmVub2RkO3N0cm9rZTojMDAwMDAwO3N0cm9rZS13aWR0aDoxLjAwMDAwMDAzcHQ7c3Ryb2tlLW9wYWNpdHk6MSIKICAgICAgICAgdHJhbnNmb3JtPSJtYXRyaXgoMC44LDAsMCwwLjgsMTAsMCkiCiAgICAgICAgIGlua3NjYXBlOmNvbm5lY3Rvci1jdXJ2YXR1cmU9IjAiIC8+CiAgICA8L21hcmtlcj4KICAgIDxtYXJrZXIKICAgICAgIGlua3NjYXBlOnN0b2NraWQ9IkFycm93MU1lbmQiCiAgICAgICBvcmllbnQ9ImF1dG8iCiAgICAgICByZWZZPSIwIgogICAgICAgcmVmWD0iMCIKICAgICAgIGlkPSJBcnJvdzFNZW5kIgogICAgICAgc3R5bGU9Im92ZXJmbG93OnZpc2libGUiCiAgICAgICBpbmtzY2FwZTppc3N0b2NrPSJ0cnVlIj4KICAgICAgPHBhdGgKICAgICAgICAgaWQ9InBhdGg5NzAiCiAgICAgICAgIGQ9Ik0gMCwwIDUsLTUgLTEyLjUsMCA1LDUgWiIKICAgICAgICAgc3R5bGU9ImZpbGw6IzAwMDAwMDtmaWxsLW9wYWNpdHk6MTtmaWxsLXJ1bGU6ZXZlbm9kZDtzdHJva2U6IzAwMDAwMDtzdHJva2Utd2lkdGg6MS4wMDAwMDAwM3B0O3N0cm9rZS1vcGFjaXR5OjEiCiAgICAgICAgIHRyYW5zZm9ybT0ibWF0cml4KC0wLjQsMCwwLC0wLjQsLTQsMCkiCiAgICAgICAgIGlua3NjYXBlOmNvbm5lY3Rvci1jdXJ2YXR1cmU9IjAiIC8+CiAgICA8L21hcmtlcj4KICAgIDxtYXJrZXIKICAgICAgIGlua3NjYXBlOnN0b2NraWQ9IkFycm93MlNlbmQiCiAgICAgICBvcmllbnQ9ImF1dG8iCiAgICAgICByZWZZPSIwIgogICAgICAgcmVmWD0iMCIKICAgICAgIGlkPSJBcnJvdzJTZW5kIgogICAgICAgc3R5bGU9Im92ZXJmbG93OnZpc2libGUiCiAgICAgICBpbmtzY2FwZTppc3N0b2NrPSJ0cnVlIj4KICAgICAgPHBhdGgKICAgICAgICAgaWQ9InBhdGg5OTQiCiAgICAgICAgIHN0eWxlPSJmaWxsOiMwMDAwMDA7ZmlsbC1vcGFjaXR5OjE7ZmlsbC1ydWxlOmV2ZW5vZGQ7c3Ryb2tlOiMwMDAwMDA7c3Ryb2tlLXdpZHRoOjAuNjI1O3N0cm9rZS1saW5lam9pbjpyb3VuZDtzdHJva2Utb3BhY2l0eToxIgogICAgICAgICBkPSJNIDguNzE4NTg3OCw0LjAzMzczNTIgLTIuMjA3Mjg5NSwwLjAxNjAxMzI2IDguNzE4NTg4NCwtNC4wMDE3MDc4IGMgLTEuNzQ1NDk4NCwyLjM3MjA2MDkgLTEuNzM1NDQwOCw1LjYxNzQ1MTkgLTZlLTcsOC4wMzU0NDMgeiIKICAgICAgICAgdHJhbnNmb3JtPSJtYXRyaXgoLTAuMywwLDAsLTAuMywwLjY5LDApIgogICAgICAgICBpbmtzY2FwZTpjb25uZWN0b3ItY3VydmF0dXJlPSIwIiAvPgogICAgPC9tYXJrZXI+CiAgICA8bWFya2VyCiAgICAgICBpbmtzY2FwZTpzdG9ja2lkPSJBcnJvdzJMc3RhcnQiCiAgICAgICBvcmllbnQ9ImF1dG8iCiAgICAgICByZWZZPSIwIgogICAgICAgcmVmWD0iMCIKICAgICAgIGlkPSJBcnJvdzJMc3RhcnQiCiAgICAgICBzdHlsZT0ib3ZlcmZsb3c6dmlzaWJsZSIKICAgICAgIGlua3NjYXBlOmlzc3RvY2s9InRydWUiPgogICAgICA8cGF0aAogICAgICAgICBpZD0icGF0aDk3OSIKICAgICAgICAgc3R5bGU9ImZpbGw6IzAwMDAwMDtmaWxsLW9wYWNpdHk6MTtmaWxsLXJ1bGU6ZXZlbm9kZDtzdHJva2U6IzAwMDAwMDtzdHJva2Utd2lkdGg6MC42MjU7c3Ryb2tlLWxpbmVqb2luOnJvdW5kO3N0cm9rZS1vcGFjaXR5OjEiCiAgICAgICAgIGQ9Ik0gOC43MTg1ODc4LDQuMDMzNzM1MiAtMi4yMDcyODk1LDAuMDE2MDEzMjYgOC43MTg1ODg0LC00LjAwMTcwNzggYyAtMS43NDU0OTg0LDIuMzcyMDYwOSAtMS43MzU0NDA4LDUuNjE3NDUxOSAtNmUtNyw4LjAzNTQ0MyB6IgogICAgICAgICB0cmFuc2Zvcm09Im1hdHJpeCgxLjEsMCwwLDEuMSwxLjEsMCkiCiAgICAgICAgIGlua3NjYXBlOmNvbm5lY3Rvci1jdXJ2YXR1cmU9IjAiIC8+CiAgICA8L21hcmtlcj4KICAgIDxtYXJrZXIKICAgICAgIGlua3NjYXBlOnN0b2NraWQ9IkFycm93MU1zdGFydCIKICAgICAgIG9yaWVudD0iYXV0byIKICAgICAgIHJlZlk9IjAiCiAgICAgICByZWZYPSIwIgogICAgICAgaWQ9IkFycm93MU1zdGFydCIKICAgICAgIHN0eWxlPSJvdmVyZmxvdzp2aXNpYmxlIgogICAgICAgaW5rc2NhcGU6aXNzdG9jaz0idHJ1ZSI+CiAgICAgIDxwYXRoCiAgICAgICAgIGlkPSJwYXRoOTY3IgogICAgICAgICBkPSJNIDAsMCA1LC01IC0xMi41LDAgNSw1IFoiCiAgICAgICAgIHN0eWxlPSJmaWxsOiMwMDAwMDA7ZmlsbC1vcGFjaXR5OjE7ZmlsbC1ydWxlOmV2ZW5vZGQ7c3Ryb2tlOiMwMDAwMDA7c3Ryb2tlLXdpZHRoOjEuMDAwMDAwMDNwdDtzdHJva2Utb3BhY2l0eToxIgogICAgICAgICB0cmFuc2Zvcm09Im1hdHJpeCgwLjQsMCwwLDAuNCw0LDApIgogICAgICAgICBpbmtzY2FwZTpjb25uZWN0b3ItY3VydmF0dXJlPSIwIiAvPgogICAgPC9tYXJrZXI+CiAgICA8bWFya2VyCiAgICAgICBpbmtzY2FwZTpzdG9ja2lkPSJBcnJvdzFMc3RhcnQiCiAgICAgICBvcmllbnQ9ImF1dG8iCiAgICAgICByZWZZPSIwIgogICAgICAgcmVmWD0iMCIKICAgICAgIGlkPSJBcnJvdzFMc3RhcnQiCiAgICAgICBzdHlsZT0ib3ZlcmZsb3c6dmlzaWJsZSIKICAgICAgIGlua3NjYXBlOmlzc3RvY2s9InRydWUiPgogICAgICA8cGF0aAogICAgICAgICBpZD0icGF0aDk2MSIKICAgICAgICAgZD0iTSAwLDAgNSwtNSAtMTIuNSwwIDUsNSBaIgogICAgICAgICBzdHlsZT0iZmlsbDojMDAwMDAwO2ZpbGwtb3BhY2l0eToxO2ZpbGwtcnVsZTpldmVub2RkO3N0cm9rZTojMDAwMDAwO3N0cm9rZS13aWR0aDoxLjAwMDAwMDAzcHQ7c3Ryb2tlLW9wYWNpdHk6MSIKICAgICAgICAgdHJhbnNmb3JtPSJtYXRyaXgoMC44LDAsMCwwLjgsMTAsMCkiCiAgICAgICAgIGlua3NjYXBlOmNvbm5lY3Rvci1jdXJ2YXR1cmU9IjAiIC8+CiAgICA8L21hcmtlcj4KICA8L2RlZnM+CiAgPHNvZGlwb2RpOm5hbWVkdmlldwogICAgIGlkPSJiYXNlIgogICAgIHBhZ2Vjb2xvcj0iI2ZmZmZmZiIKICAgICBib3JkZXJjb2xvcj0iIzY2NjY2NiIKICAgICBib3JkZXJvcGFjaXR5PSIxLjAiCiAgICAgaW5rc2NhcGU6cGFnZW9wYWNpdHk9IjAiCiAgICAgaW5rc2NhcGU6cGFnZXNoYWRvdz0iMiIKICAgICBpbmtzY2FwZTp6b29tPSIxNiIKICAgICBpbmtzY2FwZTpjeD0iMTguMTAyNDY1IgogICAgIGlua3NjYXBlOmN5PSIxMTEuMTcyNDEiCiAgICAgaW5rc2NhcGU6ZG9jdW1lbnQtdW5pdHM9InB4IgogICAgIGlua3NjYXBlOmN1cnJlbnQtbGF5ZXI9ImxheWVyMSIKICAgICBzaG93Z3JpZD0idHJ1ZSIKICAgICB1bml0cz0icHgiCiAgICAgc2hvd2d1aWRlcz0idHJ1ZSIKICAgICBvYmplY3R0b2xlcmFuY2U9IjIwIgogICAgIGdyaWR0b2xlcmFuY2U9IjUiCiAgICAgaW5rc2NhcGU6c25hcC1ncmlkcz0iZmFsc2UiCiAgICAgZml0LW1hcmdpbi10b3A9IjgiCiAgICAgZml0LW1hcmdpbi1sZWZ0PSI4IgogICAgIGZpdC1tYXJnaW4tcmlnaHQ9IjgiCiAgICAgZml0LW1hcmdpbi1ib3R0b209IjgiCiAgICAgaW5rc2NhcGU6Z3VpZGUtYmJveD0idHJ1ZSIKICAgICBndWlkZXRvbGVyYW5jZT0iOSIKICAgICBpbmtzY2FwZTpzbmFwLXRvLWd1aWRlcz0idHJ1ZSIKICAgICBpbmtzY2FwZTp3aW5kb3ctd2lkdGg9IjE5MjAiCiAgICAgaW5rc2NhcGU6d2luZG93LWhlaWdodD0iMTAxNiIKICAgICBpbmtzY2FwZTp3aW5kb3cteD0iMCIKICAgICBpbmtzY2FwZTp3aW5kb3cteT0iMjciCiAgICAgaW5rc2NhcGU6d2luZG93LW1heGltaXplZD0iMSI+CiAgICA8aW5rc2NhcGU6Z3JpZAogICAgICAgdHlwZT0ieHlncmlkIgogICAgICAgaWQ9ImdyaWQzNzEzIgogICAgICAgc3BhY2luZ3g9IjIuNjQ1ODMzNCIKICAgICAgIHNwYWNpbmd5PSIyLjY0NTgzMzQiCiAgICAgICBzbmFwdmlzaWJsZWdyaWRsaW5lc29ubHk9ImZhbHNlIgogICAgICAgZW1wc3BhY2luZz0iMyIKICAgICAgIG9yaWdpbng9IjAiCiAgICAgICBvcmlnaW55PSIwIiAvPgogICAgPHNvZGlwb2RpOmd1aWRlCiAgICAgICBwb3NpdGlvbj0iMS4zMjcxNjAzLDI0LjI4NjQ0OCIKICAgICAgIG9yaWVudGF0aW9uPSIxLDAiCiAgICAgICBpZD0iZ3VpZGU0NTM0IgogICAgICAgaW5rc2NhcGU6bG9ja2VkPSJmYWxzZSIgLz4KICAgIDxzb2RpcG9kaTpndWlkZQogICAgICAgcG9zaXRpb249IjYuNjEyNDE1MywyMi4yNjM1NTIiCiAgICAgICBvcmllbnRhdGlvbj0iMSwwIgogICAgICAgaWQ9Imd1aWRlNDUzOCIKICAgICAgIGlua3NjYXBlOmxvY2tlZD0iZmFsc2UiIC8+CiAgICA8c29kaXBvZGk6Z3VpZGUKICAgICAgIHBvc2l0aW9uPSItMi4wMDUzNTY3LDIyLjQ4NTcyIgogICAgICAgb3JpZW50YXRpb249IjAsMSIKICAgICAgIGlkPSJndWlkZTQ1NDAiCiAgICAgICBpbmtzY2FwZTpsb2NrZWQ9ImZhbHNlIiAvPgogICAgPHNvZGlwb2RpOmd1aWRlCiAgICAgICBwb3NpdGlvbj0iLTEuNzM2MzI4MiwxNy4xOTc5MTciCiAgICAgICBvcmllbnRhdGlvbj0iMCwxIgogICAgICAgaWQ9Imd1aWRlNDU0MiIKICAgICAgIGlua3NjYXBlOmxvY2tlZD0iZmFsc2UiIC8+CiAgICA8c29kaXBvZGk6Z3VpZGUKICAgICAgIHBvc2l0aW9uPSItMS44MTkwMTA1LDE0LjU1MjA4NCIKICAgICAgIG9yaWVudGF0aW9uPSIwLDEiCiAgICAgICBpZD0iZ3VpZGU0NTQ0IgogICAgICAgaW5rc2NhcGU6bG9ja2VkPSJmYWxzZSIgLz4KICAgIDxzb2RpcG9kaTpndWlkZQogICAgICAgcG9zaXRpb249Ii0xLjI4OTg0MzgsOS4yNDM4ODA0IgogICAgICAgb3JpZW50YXRpb249IjAsMSIKICAgICAgIGlkPSJndWlkZTQ1NDYiCiAgICAgICBpbmtzY2FwZTpsb2NrZWQ9ImZhbHNlIiAvPgogICAgPHNvZGlwb2RpOmd1aWRlCiAgICAgICBwb3NpdGlvbj0iLTEuNDM4NjcxOSw2LjYxNDU4MzUiCiAgICAgICBvcmllbnRhdGlvbj0iMCwxIgogICAgICAgaWQ9Imd1aWRlNDU0OCIKICAgICAgIGlua3NjYXBlOmxvY2tlZD0iZmFsc2UiIC8+CiAgICA8c29kaXBvZGk6Z3VpZGUKICAgICAgIHBvc2l0aW9uPSItMC45OTIxODc1MiwxLjI4OTg0MzgiCiAgICAgICBvcmllbnRhdGlvbj0iMCwxIgogICAgICAgaWQ9Imd1aWRlNDU1MCIKICAgICAgIGlua3NjYXBlOmxvY2tlZD0iZmFsc2UiIC8+CiAgICA8c29kaXBvZGk6Z3VpZGUKICAgICAgIHBvc2l0aW9uPSItNC4zMjY0MjU1LDExLjkwMzUxNyIKICAgICAgIG9yaWVudGF0aW9uPSIwLDEiCiAgICAgICBpZD0iZ3VpZGU0NTUyIgogICAgICAgaW5rc2NhcGU6bG9ja2VkPSJmYWxzZSIgLz4KICAgIDxzb2RpcG9kaTpndWlkZQogICAgICAgcG9zaXRpb249Ii0xMi43MzMwNzMsMzAuNDI3MDg0IgogICAgICAgb3JpZW50YXRpb249IjAsMSIKICAgICAgIGlkPSJndWlkZTk0MSIKICAgICAgIGlua3NjYXBlOmxvY2tlZD0iZmFsc2UiIC8+CiAgICA8c29kaXBvZGk6Z3VpZGUKICAgICAgIHBvc2l0aW9uPSItMTcuMDQ4NDU1LDI1LjE0MDA0MSIKICAgICAgIG9yaWVudGF0aW9uPSIwLDEiCiAgICAgICBpZD0iZ3VpZGU5NDkiCiAgICAgICBpbmtzY2FwZTpsb2NrZWQ9ImZhbHNlIiAvPgogICAgPHNvZGlwb2RpOmd1aWRlCiAgICAgICBwb3NpdGlvbj0iLTUuOTYzNDUxMywyOC40Mzc0NzkiCiAgICAgICBvcmllbnRhdGlvbj0iMCwxIgogICAgICAgaWQ9Imd1aWRlOTU4IgogICAgICAgaW5rc2NhcGU6bG9ja2VkPSJmYWxzZSIgLz4KICAgIDxzb2RpcG9kaTpndWlkZQogICAgICAgcG9zaXRpb249Ii03LjE1NjE0MTYsMjUuODQxNjIzIgogICAgICAgb3JpZW50YXRpb249IjAsMSIKICAgICAgIGlkPSJndWlkZTk2MCIKICAgICAgIGlua3NjYXBlOmxvY2tlZD0iZmFsc2UiIC8+CiAgPC9zb2RpcG9kaTpuYW1lZHZpZXc+CiAgPG1ldGFkYXRhCiAgICAgaWQ9Im1ldGFkYXRhNSI+CiAgICA8cmRmOlJERj4KICAgICAgPGNjOldvcmsKICAgICAgICAgcmRmOmFib3V0PSIiPgogICAgICAgIDxkYzpmb3JtYXQ+aW1hZ2Uvc3ZnK3htbDwvZGM6Zm9ybWF0PgogICAgICAgIDxkYzp0eXBlCiAgICAgICAgICAgcmRmOnJlc291cmNlPSJodHRwOi8vcHVybC5vcmcvZGMvZGNtaXR5cGUvU3RpbGxJbWFnZSIgLz4KICAgICAgICA8ZGM6dGl0bGU+PC9kYzp0aXRsZT4KICAgICAgICA8Y2M6bGljZW5zZQogICAgICAgICAgIHJkZjpyZXNvdXJjZT0iaHR0cHM6Ly93d3cuZ251Lm9yZy9saWNlbnNlcy9ncGwtMy4wLnR4dCIgLz4KICAgICAgPC9jYzpXb3JrPgogICAgPC9yZGY6UkRGPgogIDwvbWV0YWRhdGE+CiAgPGcKICAgICBpbmtzY2FwZTpsYWJlbD0iQ2FscXVlIDEiCiAgICAgaW5rc2NhcGU6Z3JvdXBtb2RlPSJsYXllciIKICAgICBpZD0ibGF5ZXIxIgogICAgIHRyYW5zZm9ybT0idHJhbnNsYXRlKDEuNTU2OTkzNCwtMjU5LjIyMzg0KSI+CiAgICA8ZwogICAgICAgaWQ9Imc0NjcwIgogICAgICAgdHJhbnNmb3JtPSJtYXRyaXgoMC44MzY0NzYyNiwwLDAsMC44MzMzMTMwNSwwLjM5MTczNTYzLDQ2LjUxNjg3NykiPgogICAgICA8cmVjdAogICAgICAgICB0cmFuc2Zvcm09Im1hdHJpeCgxLDAsLTAuMzM0ODI0OTcsMC45NDIyODAzNCwwLDApIgogICAgICAgICByeT0iMC42NDczODQ3IgogICAgICAgICB5PSIyOTIuNzkyNDUiCiAgICAgICAgIHg9Ijk5LjUyODIwNiIKICAgICAgICAgaGVpZ2h0PSI2LjczODQxMjkiCiAgICAgICAgIHdpZHRoPSI0LjA4MTQxNzEiCiAgICAgICAgIGlkPSJyZWN0NDUzMiIKICAgICAgICAgc3R5bGU9ImZpbGw6bm9uZTtzdHJva2U6IzAwMDAwMDtzdHJva2Utd2lkdGg6MC4yMzA0NjQ0NDtzdHJva2UtbGluZWNhcDpyb3VuZDtzdHJva2UtbGluZWpvaW46cm91bmQ7c3Ryb2tlLW1pdGVybGltaXQ6MDtzdHJva2UtZGFzaGFycmF5Om5vbmU7c3Ryb2tlLW9wYWNpdHk6MSIgLz4KICAgICAgPHJlY3QKICAgICAgICAgdHJhbnNmb3JtPSJtYXRyaXgoMSwwLC0wLjMzNDgyNDk4LDAuOTQyMjgwMzQsMCwwKSIKICAgICAgICAgcnk9IjAuNTc0OTAwMjEiCiAgICAgICAgIHk9IjI5NS44OTg2OCIKICAgICAgICAgeD0iOTkuNTI2NDUxIgogICAgICAgICBoZWlnaHQ9IjMuNjMyMTU4OCIKICAgICAgICAgd2lkdGg9IjQuMDgzMTY5NSIKICAgICAgICAgaWQ9InJlY3Q0NTMyLTMiCiAgICAgICAgIHN0eWxlPSJmaWxsOiMwMDAwMDA7ZmlsbC1vcGFjaXR5OjE7c3Ryb2tlOiMwMDAwMDA7c3Ryb2tlLXdpZHRoOjAuMjMwNDY0NDQ7c3Ryb2tlLWxpbmVjYXA6cm91bmQ7c3Ryb2tlLWxpbmVqb2luOnJvdW5kO3N0cm9rZS1taXRlcmxpbWl0OjA7c3Ryb2tlLWRhc2hhcnJheTpub25lO3N0cm9rZS1vcGFjaXR5OjEiIC8+CiAgICA8L2c+CiAgICA8cmVjdAogICAgICAgc3R5bGU9ImZpbGw6IzAwMDAwMDtmaWxsLW9wYWNpdHk6MTtzdHJva2U6IzAwMDAwMDtzdHJva2Utd2lkdGg6MC4xMDI0MDM2NDtzdHJva2UtbGluZWNhcDpyb3VuZDtzdHJva2UtbGluZWpvaW46YmV2ZWw7c3Ryb2tlLW1pdGVybGltaXQ6MDtzdHJva2UtZGFzaGFycmF5Om5vbmU7c3Ryb2tlLW9wYWNpdHk6MSIKICAgICAgIGlkPSJyZWN0NDYzMyIKICAgICAgIHdpZHRoPSIwLjUzNjc5NTk3IgogICAgICAgaGVpZ2h0PSIzLjA3NzAxMTEiCiAgICAgICB4PSI4NS4wMjA1MzgiCiAgICAgICB5PSIyODAuNjQyNzkiCiAgICAgICByeT0iMC4yMDI3NTE2NSIKICAgICAgIHRyYW5zZm9ybT0ibWF0cml4KDEsMCwtMC4yOTExMDkwMiwwLjk1NjY4OTg5LDAsMCkiCiAgICAgICByeD0iMC4yNjgzOTc5OSIgLz4KICAgIDxyZWN0CiAgICAgICBzdHlsZT0iZmlsbDojMDAwMDAwO2ZpbGwtb3BhY2l0eToxO3N0cm9rZTojMDAwMDAwO3N0cm9rZS13aWR0aDowLjE2NzQxNjk1O3N0cm9rZS1saW5lY2FwOnJvdW5kO3N0cm9rZS1saW5lam9pbjpiZXZlbDtzdHJva2UtbWl0ZXJsaW1pdDowO3N0cm9rZS1kYXNoYXJyYXk6bm9uZTtzdHJva2Utb3BhY2l0eToxIgogICAgICAgaWQ9InJlY3Q0NjM5IgogICAgICAgd2lkdGg9IjMuMzc3NTQ5NiIKICAgICAgIGhlaWdodD0iMC4zMzIyMTgwMiIKICAgICAgIHg9IjEuMDUzMjMyMSIKICAgICAgIHk9IjI3MS4zMzk2NiIKICAgICAgIHJ5PSIwLjE2NjEwOTAxIiAvPgogICAgPHBhdGgKICAgICAgIHN0eWxlPSJmaWxsOm5vbmU7c3Ryb2tlOiMwMDAwMDA7c3Ryb2tlLXdpZHRoOjAuMjIxODI3NDM7c3Ryb2tlLWxpbmVjYXA6YnV0dDtzdHJva2UtbGluZWpvaW46cm91bmQ7c3Ryb2tlLW1pdGVybGltaXQ6NDtzdHJva2UtZGFzaGFycmF5Om5vbmU7c3Ryb2tlLW9wYWNpdHk6MSIKICAgICAgIGQ9Im0gMS4zMTYyMzgsMjcxLjY0NDIgYyAtMC4yNDkxNjM2LDEuMjQ1ODEgLTEuMjA0MjkwMjksMi4xMzE3MiAtMS4yMDQyOTAyOSwyLjEzMTcyIGwgNC41NDAzMTI3OSwwLjAyNzYgYyAwLDAgLTAuNTg4MzAzLC0xLjMxNDk3IC0wLjQ0OTg3ODgsLTIuMjI4NTkiCiAgICAgICBpZD0icGF0aDQ2NDEiCiAgICAgICBpbmtzY2FwZTpjb25uZWN0b3ItY3VydmF0dXJlPSIwIgogICAgICAgc29kaXBvZGk6bm9kZXR5cGVzPSJjY2NjIiAvPgogICAgPHBhdGgKICAgICAgIHN0eWxlPSJmaWxsOm5vbmU7c3Ryb2tlOiMwMDAwMDA7c3Ryb2tlLXdpZHRoOjAuMjIxNDc4NjdweDtzdHJva2UtbGluZWNhcDpyb3VuZDtzdHJva2UtbGluZWpvaW46cm91bmQ7c3Ryb2tlLW9wYWNpdHk6MSIKICAgICAgIGQ9Im0gMS43NzMwMzc4LDI3MS42NDQxOSBjIC0wLjIwNzYzNjMsMC45NzU4OSAtMC43MjY3MjcsMS43NzE4MyAtMC43MjY3MjcsMS43NzE4MyIKICAgICAgIGlkPSJwYXRoNDY0MyIKICAgICAgIGlua3NjYXBlOmNvbm5lY3Rvci1jdXJ2YXR1cmU9IjAiCiAgICAgICBzb2RpcG9kaTpub2RldHlwZXM9ImNjIiAvPgogICAgPHBhdGgKICAgICAgIHN0eWxlPSJmaWxsOm5vbmU7c3Ryb2tlOiMwMDAwMDA7c3Ryb2tlLXdpZHRoOjAuMjIxNDc4NjdweDtzdHJva2UtbGluZWNhcDpyb3VuZDtzdHJva2UtbGluZWpvaW46cm91bmQ7c3Ryb2tlLW9wYWNpdHk6MSIKICAgICAgIGQ9Im0gMi4xNjc1NDYyLDI3MS42NTgwMyBjIC0wLjE2NjEwOSwwLjkwNjY4IC0wLjUzOTg1NDIsMS43NTc5OSAtMC41Mzk4NTQyLDEuNzU3OTkiCiAgICAgICBpZD0icGF0aDQ2NDUiCiAgICAgICBpbmtzY2FwZTpjb25uZWN0b3ItY3VydmF0dXJlPSIwIgogICAgICAgc29kaXBvZGk6bm9kZXR5cGVzPSJjYyIgLz4KICAgIDxwYXRoCiAgICAgICBzdHlsZT0iZmlsbDpub25lO3N0cm9rZTojMDAwMDAwO3N0cm9rZS13aWR0aDowLjIyMTQ3ODY3cHg7c3Ryb2tlLWxpbmVjYXA6cm91bmQ7c3Ryb2tlLWxpbmVqb2luOnJvdW5kO3N0cm9rZS1vcGFjaXR5OjEiCiAgICAgICBkPSJtIDIuNTc5NDIzNCwyNzEuNjM3MjYgYyAtMC4xMTc2NjA2LDAuOTU1MTMgLTAuMzg3NTg3NywxLjc3ODc2IC0wLjM4NzU4NzcsMS43Nzg3NiIKICAgICAgIGlkPSJwYXRoNDY0NyIKICAgICAgIGlua3NjYXBlOmNvbm5lY3Rvci1jdXJ2YXR1cmU9IjAiCiAgICAgICBzb2RpcG9kaTpub2RldHlwZXM9ImNjIiAvPgogICAgPHBhdGgKICAgICAgIHN0eWxlPSJmaWxsOm5vbmU7c3Ryb2tlOiMwMDAwMDA7c3Ryb2tlLXdpZHRoOjAuMjIxNDc4NjdweDtzdHJva2UtbGluZWNhcDpyb3VuZDtzdHJva2UtbGluZWpvaW46cm91bmQ7c3Ryb2tlLW9wYWNpdHk6MSIKICAgICAgIGQ9Im0gMi45NzcyOTYzLDI3MS42NTExMiBjIC0wLjE3MzAzMDIsMS4zMjg4NyAtMC4yMDc2MzYyLDEuNzY0OSAtMC4yMDc2MzYyLDEuNzY0OSIKICAgICAgIGlkPSJwYXRoNDY0OSIKICAgICAgIGlua3NjYXBlOmNvbm5lY3Rvci1jdXJ2YXR1cmU9IjAiCiAgICAgICBzb2RpcG9kaTpub2RldHlwZXM9ImNjIiAvPgogICAgPHBhdGgKICAgICAgIHN0eWxlPSJmaWxsOm5vbmU7c3Ryb2tlOiMwMDAwMDA7c3Ryb2tlLXdpZHRoOjAuMjIxNDc4NjdweDtzdHJva2UtbGluZWNhcDpyb3VuZDtzdHJva2UtbGluZWpvaW46cm91bmQ7c3Ryb2tlLW9wYWNpdHk6MSIKICAgICAgIGQ9Im0gMy4zNjExOTYxLDI3MS42NjQ5NiBjIDAuMDIwNzY0LDEuMDY1ODUgLTAuMDA2OTMsMS43NTEwNiAtMC4wMDY5MywxLjc1MTA2IgogICAgICAgaWQ9InBhdGg0NjUxIgogICAgICAgaW5rc2NhcGU6Y29ubmVjdG9yLWN1cnZhdHVyZT0iMCIKICAgICAgIHNvZGlwb2RpOm5vZGV0eXBlcz0iY2MiIC8+CiAgICA8cGF0aAogICAgICAgc3R5bGU9ImZpbGw6bm9uZTtzdHJva2U6IzAwMDAwMDtzdHJva2Utd2lkdGg6MC4yMjE0Nzg2N3B4O3N0cm9rZS1saW5lY2FwOnJvdW5kO3N0cm9rZS1saW5lam9pbjpyb3VuZDtzdHJva2Utb3BhY2l0eToxIgogICAgICAgZD0ibSAzLjcxNzg5NzMsMjcxLjY3MTg4IGMgMC4wMjA3NjQsMC44NjUxNSAwLjI2MzAwNTksMS43NDQxNCAwLjI2MzAwNTksMS43NDQxNCIKICAgICAgIGlkPSJwYXRoNDY1MyIKICAgICAgIGlua3NjYXBlOmNvbm5lY3Rvci1jdXJ2YXR1cmU9IjAiCiAgICAgICBzb2RpcG9kaTpub2RldHlwZXM9ImNjIiAvPgogICAgPGVsbGlwc2UKICAgICAgIHN0eWxlPSJmaWxsOm5vbmU7ZmlsbC1vcGFjaXR5OjE7c3Ryb2tlOiMwMDAwMDA7c3Ryb2tlLXdpZHRoOjAuMTk1NjU4NTY7c3Ryb2tlLWxpbmVjYXA6cm91bmQ7c3Ryb2tlLWxpbmVqb2luOnJvdW5kO3N0cm9rZS1taXRlcmxpbWl0OjQ7c3Ryb2tlLWRhc2hhcnJheTpub25lO3N0cm9rZS1kYXNob2Zmc2V0OjA7c3Ryb2tlLW9wYWNpdHk6MSIKICAgICAgIGlkPSJwYXRoOTUxIgogICAgICAgY3g9IjIuNDMwMzM0MSIKICAgICAgIGN5PSIyODcuMDA5OTUiCiAgICAgICByeD0iMi43ODM1NjUzIgogICAgICAgcnk9IjIuODIwODQ3NSIgLz4KICAgIDxwYXRoCiAgICAgICBzdHlsZT0iZmlsbDpub25lO3N0cm9rZTojMDAwMDAwO3N0cm9rZS13aWR0aDowLjE1MTQwODMzO3N0cm9rZS1saW5lY2FwOmJ1dHQ7c3Ryb2tlLWxpbmVqb2luOm1pdGVyO3N0cm9rZS1taXRlcmxpbWl0OjQ7c3Ryb2tlLWRhc2hhcnJheTowLjQ1NDIyNDk2LCAwLjE1MTQwODMzO3N0cm9rZS1kYXNob2Zmc2V0OjAuMTQyODc0OTk7c3Ryb2tlLW9wYWNpdHk6MTttYXJrZXItc3RhcnQ6dXJsKCNBcnJvdzJMc3RhcnQpO21hcmtlci1lbmQ6dXJsKCNBcnJvdzJMZW5kKSIKICAgICAgIGQ9Ik0gMC4wMjY0ODAxMiwyODcuMDA5OTUgSCA0LjgzNDE4ODEiCiAgICAgICBpZD0icGF0aDc2OTMiCiAgICAgICBpbmtzY2FwZTpjb25uZWN0b3ItY3VydmF0dXJlPSIwIiAvPgogICAgPHJlY3QKICAgICAgIHN0eWxlPSJmaWxsOm5vbmU7ZmlsbC1vcGFjaXR5OjE7c3Ryb2tlOiMwMDAwMDA7c3Ryb2tlLXdpZHRoOjAuMTU5O3N0cm9rZS1saW5lY2FwOnJvdW5kO3N0cm9rZS1saW5lam9pbjpyb3VuZDtzdHJva2UtbWl0ZXJsaW1pdDo0O3N0cm9rZS1kYXNoYXJyYXk6bm9uZTtzdHJva2UtZGFzaG9mZnNldDowLjU0MDg1MDM3O3N0cm9rZS1vcGFjaXR5OjEiCiAgICAgICBpZD0icmVjdDk1NCIKICAgICAgIHdpZHRoPSIyLjY0MjYyNzUiCiAgICAgICBoZWlnaHQ9IjQuMDIyNDA1NiIKICAgICAgIHg9IjEuMTA5MDIwNCIKICAgICAgIHk9IjI2MS44MTE0IgogICAgICAgcng9IjAuMzIwNjM1MzIiCiAgICAgICByeT0iMC4yNDIyMTE1MSIgLz4KICAgIDxyZWN0CiAgICAgICBzdHlsZT0iZmlsbDpub25lO2ZpbGwtb3BhY2l0eToxO3N0cm9rZTojMDAwMDAwO3N0cm9rZS13aWR0aDowLjE1OTAwMDAxO3N0cm9rZS1saW5lY2FwOnJvdW5kO3N0cm9rZS1saW5lam9pbjpyb3VuZDtzdHJva2UtbWl0ZXJsaW1pdDo0O3N0cm9rZS1kYXNoYXJyYXk6bm9uZTtzdHJva2UtZGFzaG9mZnNldDoyLjA0NDE1ODk0O3N0cm9rZS1vcGFjaXR5OjEiCiAgICAgICBpZD0icmVjdDk1NiIKICAgICAgIHdpZHRoPSIzLjU3ODA3MDkiCiAgICAgICBoZWlnaHQ9IjAuNTg0NjUyMTMiCiAgICAgICB4PSIwLjYwMjc5NDY1IgogICAgICAgeT0iMjYxLjIyMzkxIgogICAgICAgcng9IjAuMzIwNjM1MzIiCiAgICAgICByeT0iMC4yNDIyMTE1MSIgLz4KICAgIDxwYXRoCiAgICAgICBzdHlsZT0iZmlsbDpub25lO3N0cm9rZTojMDAwMDAwO3N0cm9rZS13aWR0aDowLjA2NTtzdHJva2UtbGluZWNhcDpidXR0O3N0cm9rZS1saW5lam9pbjptaXRlcjtzdHJva2UtbWl0ZXJsaW1pdDo0O3N0cm9rZS1kYXNoYXJyYXk6bm9uZTtzdHJva2Utb3BhY2l0eToxIgogICAgICAgZD0ibSAyLjEzMzM5MywyNjIuNTM2MzYgdiAyLjU5NTg2IgogICAgICAgaWQ9InBhdGg5NjgiCiAgICAgICBpbmtzY2FwZTpjb25uZWN0b3ItY3VydmF0dXJlPSIwIiAvPgogICAgPHBhdGgKICAgICAgIHN0eWxlPSJmaWxsOm5vbmU7c3Ryb2tlOiMwMDAwMDA7c3Ryb2tlLXdpZHRoOjAuMDY1O3N0cm9rZS1saW5lY2FwOmJ1dHQ7c3Ryb2tlLWxpbmVqb2luOm1pdGVyO3N0cm9rZS1taXRlcmxpbWl0OjQ7c3Ryb2tlLWRhc2hhcnJheTpub25lO3N0cm9rZS1vcGFjaXR5OjEiCiAgICAgICBkPSJtIDIuNzE0OTI1MiwyNjIuNTM2MzYgdiAyLjU5NTg2IgogICAgICAgaWQ9InBhdGg5NjgtNiIKICAgICAgIGlua3NjYXBlOmNvbm5lY3Rvci1jdXJ2YXR1cmU9IjAiIC8+CiAgICA8cGF0aAogICAgICAgc3R5bGU9ImZpbGw6bm9uZTtzdHJva2U6IzAwMDAwMDtzdHJva2Utd2lkdGg6MC4wNjU7c3Ryb2tlLWxpbmVjYXA6YnV0dDtzdHJva2UtbGluZWpvaW46bWl0ZXI7c3Ryb2tlLW1pdGVybGltaXQ6NDtzdHJva2UtZGFzaGFycmF5Om5vbmU7c3Ryb2tlLW9wYWNpdHk6MSIKICAgICAgIGQ9Im0gMS41NTE4NjA4LDI2Mi41MzYzNiB2IDIuNTk1ODYiCiAgICAgICBpZD0icGF0aDk2OC03IgogICAgICAgaW5rc2NhcGU6Y29ubmVjdG9yLWN1cnZhdHVyZT0iMCIgLz4KICAgIDxwYXRoCiAgICAgICBzdHlsZT0iZmlsbDpub25lO3N0cm9rZTojMDAwMDAwO3N0cm9rZS13aWR0aDowLjA2NTtzdHJva2UtbGluZWNhcDpidXR0O3N0cm9rZS1saW5lam9pbjptaXRlcjtzdHJva2UtbWl0ZXJsaW1pdDo0O3N0cm9rZS1kYXNoYXJyYXk6bm9uZTtzdHJva2Utb3BhY2l0eToxIgogICAgICAgZD0ibSAzLjI5NjQ1NzIsMjYyLjUzNjM2IHYgMi41OTU4NiIKICAgICAgIGlkPSJwYXRoOTY4LTUiCiAgICAgICBpbmtzY2FwZTpjb25uZWN0b3ItY3VydmF0dXJlPSIwIiAvPgogIDwvZz4KPC9zdmc+Cg==\"","/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n// css base code, injected by the css-loader\nmodule.exports = function(useSourceMap) {\n\tvar list = [];\n\n\t// return the list of modules as css string\n\tlist.toString = function toString() {\n\t\treturn this.map(function (item) {\n\t\t\tvar content = cssWithMappingToString(item, useSourceMap);\n\t\t\tif(item[2]) {\n\t\t\t\treturn \"@media \" + item[2] + \"{\" + content + \"}\";\n\t\t\t} else {\n\t\t\t\treturn content;\n\t\t\t}\n\t\t}).join(\"\");\n\t};\n\n\t// import a list of modules into the list\n\tlist.i = function(modules, mediaQuery) {\n\t\tif(typeof modules === \"string\")\n\t\t\tmodules = [[null, modules, \"\"]];\n\t\tvar alreadyImportedModules = {};\n\t\tfor(var i = 0; i < this.length; i++) {\n\t\t\tvar id = this[i][0];\n\t\t\tif(typeof id === \"number\")\n\t\t\t\talreadyImportedModules[id] = true;\n\t\t}\n\t\tfor(i = 0; i < modules.length; i++) {\n\t\t\tvar item = modules[i];\n\t\t\t// skip already imported module\n\t\t\t// this implementation is not 100% perfect for weird media query combinations\n\t\t\t//  when a module is imported multiple times with different media queries.\n\t\t\t//  I hope this will never occur (Hey this way we have smaller bundles)\n\t\t\tif(typeof item[0] !== \"number\" || !alreadyImportedModules[item[0]]) {\n\t\t\t\tif(mediaQuery && !item[2]) {\n\t\t\t\t\titem[2] = mediaQuery;\n\t\t\t\t} else if(mediaQuery) {\n\t\t\t\t\titem[2] = \"(\" + item[2] + \") and (\" + mediaQuery + \")\";\n\t\t\t\t}\n\t\t\t\tlist.push(item);\n\t\t\t}\n\t\t}\n\t};\n\treturn list;\n};\n\nfunction cssWithMappingToString(item, useSourceMap) {\n\tvar content = item[1] || '';\n\tvar cssMapping = item[3];\n\tif (!cssMapping) {\n\t\treturn content;\n\t}\n\n\tif (useSourceMap && typeof btoa === 'function') {\n\t\tvar sourceMapping = toComment(cssMapping);\n\t\tvar sourceURLs = cssMapping.sources.map(function (source) {\n\t\t\treturn '/*# sourceURL=' + cssMapping.sourceRoot + source + ' */'\n\t\t});\n\n\t\treturn [content].concat(sourceURLs).concat([sourceMapping]).join('\\n');\n\t}\n\n\treturn [content].join('\\n');\n}\n\n// Adapted from convert-source-map (MIT)\nfunction toComment(sourceMap) {\n\t// eslint-disable-next-line no-undef\n\tvar base64 = btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap))));\n\tvar data = 'sourceMappingURL=data:application/json;charset=utf-8;base64,' + base64;\n\n\treturn '/*# ' + data + ' */';\n}\n","module.exports = function escape(url) {\n    if (typeof url !== 'string') {\n        return url\n    }\n    // If url is already wrapped in quotes, remove them\n    if (/^['\"].*['\"]$/.test(url)) {\n        url = url.slice(1, -1);\n    }\n    // Should url be wrapped?\n    // See https://drafts.csswg.org/css-values-3/#urls\n    if (/[\"'() \\t\\n]/.test(url)) {\n        return '\"' + url.replace(/\"/g, '\\\\\"').replace(/\\n/g, '\\\\n') + '\"'\n    }\n\n    return url\n}\n","var escape = require(\"../node_modules/css-loader/lib/url/escape.js\");\nexports = module.exports = require(\"../node_modules/css-loader/lib/css-base.js\")(false);\n// imports\n\n\n// module\nexports.push([module.id, \"\\n/*   Icons  */\\n\\n.leaflet-control-paintpolygon-icon {\\n    background-image: url(\" + escape(require(\"./PaintPolygon.svg\")) + \");\\n    background-repeat: no-repeat;\\n    height: 30px;\\n    width: 30px;\\n}\\n\\n.leaflet-control-paintpolygon-icon-active {\\n    -webkit-filter: invert(75%); /* Safari 6.0 - 9.0 */\\n    filter: invert(75%);\\n}\\n\\n.leaflet-control-paintpolygon-icon.leaflet-control-paintpolygon-icon-trash {\\n    background-position: 0px 0px;\\n}\\n\\n.leaflet-control-paintpolygon-icon.leaflet-control-paintpolygon-icon-brush {\\n    background-position: 0px -30px;\\n}\\n\\n.leaflet-control-paintpolygon-icon.leaflet-control-paintpolygon-icon-eraser {\\n    background-position: 0px -60px;\\n}\\n\\n.leaflet-control-paintpolygon-icon.leaflet-control-paintpolygon-icon-size {\\n    background-position: 0px -90px;\\n}\\n\\n\\n/* Menu */\\n\\n.leaflet-control-paintpolygon-menu  {\\n    background-color: #fff;\\n    position: absolute;\\n    border: 0!important;\\n    max-width: 0;\\n    max-height: 30px;\\n    -webkit-transition: all 0.5s;\\n    -moz-transition: all 0.5s;\\n    -ms-transition: all 0.5s;\\n    -o-transition: all 0.5s;\\n    transition: all 0.5s;\\n    display: inline-block;\\n    overflow: hidden;\\n    white-space: nowrap;\\n}\\n.leaflet-control-paintpolygon-menu-content  {\\n    padding: 5px;\\n    display: inline-block;\\n    max-width: 250px;\\n}\\n\\n.leaflet-control-paintpolygon-menu-open  {\\n    border: inherit!important;\\n    max-width: 250px;\\n    max-height: 200px;\\n}\\n\\n.leaflet-control-container .leaflet-top.leaflet-right .leaflet-control-paintpolygon-menu {\\n    top: 60px;\\n    right: 30px;\\n}\\n.leaflet-control-container .leaflet-top.leaflet-left .leaflet-control-paintpolygon-menu {\\n    top: 60px;\\n    left: 30px;\\n}\\n.leaflet-control-container .leaflet-bottom.leaflet-right .leaflet-control-paintpolygon-menu {\\n    bottom: 0px;\\n    right: 30px;\\n}\\n.leaflet-control-container .leaflet-bottom.leaflet-left .leaflet-control-paintpolygon-menu {\\n    bottom: 0px;\\n    left: 30px;\\n}\\n\\n\", \"\"]);\n\n// exports\n","\nvar content = require(\"!!../node_modules/css-loader/index.js!./PaintPolygon.css\");\n\nif(typeof content === 'string') content = [[module.id, content, '']];\n\nvar transform;\nvar insertInto;\n\n\n\nvar options = {\"hmr\":true}\n\noptions.transform = transform\noptions.insertInto = undefined;\n\nvar update = require(\"!../node_modules/style-loader/lib/addStyles.js\")(content, options);\n\nif(content.locals) module.exports = content.locals;\n\nif(module.hot) {\n\tmodule.hot.accept(\"!!../node_modules/css-loader/index.js!./PaintPolygon.css\", function() {\n\t\tvar newContent = require(\"!!../node_modules/css-loader/index.js!./PaintPolygon.css\");\n\n\t\tif(typeof newContent === 'string') newContent = [[module.id, newContent, '']];\n\n\t\tvar locals = (function(a, b) {\n\t\t\tvar key, idx = 0;\n\n\t\t\tfor(key in a) {\n\t\t\t\tif(!b || a[key] !== b[key]) return false;\n\t\t\t\tidx++;\n\t\t\t}\n\n\t\t\tfor(key in b) idx--;\n\n\t\t\treturn idx === 0;\n\t\t}(content.locals, newContent.locals));\n\n\t\tif(!locals) throw new Error('Aborting CSS HMR due to changed css-modules locals.');\n\n\t\tupdate(newContent);\n\t});\n\n\tmodule.hot.dispose(function() { update(); });\n}","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar meta_1 = require(\"@turf/meta\");\n// Note: change RADIUS => earthRadius\nvar RADIUS = 6378137;\n/**\n * Takes one or more features and returns their area in square meters.\n *\n * @name area\n * @param {GeoJSON} geojson input GeoJSON feature(s)\n * @returns {number} area in square meters\n * @example\n * var polygon = turf.polygon([[[125, -15], [113, -22], [154, -27], [144, -15], [125, -15]]]);\n *\n * var area = turf.area(polygon);\n *\n * //addToMap\n * var addToMap = [polygon]\n * polygon.properties.area = area\n */\nfunction area(geojson) {\n    return meta_1.geomReduce(geojson, function (value, geom) {\n        return value + calculateArea(geom);\n    }, 0);\n}\nexports.default = area;\n/**\n * Calculate Area\n *\n * @private\n * @param {Geometry} geom GeoJSON Geometries\n * @returns {number} area\n */\nfunction calculateArea(geom) {\n    var total = 0;\n    var i;\n    switch (geom.type) {\n        case \"Polygon\":\n            return polygonArea(geom.coordinates);\n        case \"MultiPolygon\":\n            for (i = 0; i < geom.coordinates.length; i++) {\n                total += polygonArea(geom.coordinates[i]);\n            }\n            return total;\n        case \"Point\":\n        case \"MultiPoint\":\n        case \"LineString\":\n        case \"MultiLineString\":\n            return 0;\n    }\n    return 0;\n}\nfunction polygonArea(coords) {\n    var total = 0;\n    if (coords && coords.length > 0) {\n        total += Math.abs(ringArea(coords[0]));\n        for (var i = 1; i < coords.length; i++) {\n            total -= Math.abs(ringArea(coords[i]));\n        }\n    }\n    return total;\n}\n/**\n * @private\n * Calculate the approximate area of the polygon were it projected onto the earth.\n * Note that this area will be positive if ring is oriented clockwise, otherwise it will be negative.\n *\n * Reference:\n * Robert. G. Chamberlain and William H. Duquette, \"Some Algorithms for Polygons on a Sphere\",\n * JPL Publication 07-03, Jet Propulsion\n * Laboratory, Pasadena, CA, June 2007 http://trs-new.jpl.nasa.gov/dspace/handle/2014/40409\n *\n * @param {Array<Array<number>>} coords Ring Coordinates\n * @returns {number} The approximate signed geodesic area of the polygon in square meters.\n */\nfunction ringArea(coords) {\n    var p1;\n    var p2;\n    var p3;\n    var lowerIndex;\n    var middleIndex;\n    var upperIndex;\n    var i;\n    var total = 0;\n    var coordsLength = coords.length;\n    if (coordsLength > 2) {\n        for (i = 0; i < coordsLength; i++) {\n            if (i === coordsLength - 2) {\n                lowerIndex = coordsLength - 2;\n                middleIndex = coordsLength - 1;\n                upperIndex = 0;\n            }\n            else if (i === coordsLength - 1) {\n                lowerIndex = coordsLength - 1;\n                middleIndex = 0;\n                upperIndex = 1;\n            }\n            else {\n                lowerIndex = i;\n                middleIndex = i + 1;\n                upperIndex = i + 2;\n            }\n            p1 = coords[lowerIndex];\n            p2 = coords[middleIndex];\n            p3 = coords[upperIndex];\n            total += (rad(p3[0]) - rad(p1[0])) * Math.sin(rad(p2[1]));\n        }\n        total = total * RADIUS * RADIUS / 2;\n    }\n    return total;\n}\nfunction rad(num) {\n    return num * Math.PI / 180;\n}\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n// http://en.wikipedia.org/wiki/Haversine_formula\n// http://www.movable-type.co.uk/scripts/latlong.html\nvar helpers_1 = require(\"@turf/helpers\");\nvar invariant_1 = require(\"@turf/invariant\");\n/**\n * Takes a {@link Point} and calculates the location of a destination point given a distance in\n * degrees, radians, miles, or kilometers; and bearing in degrees.\n * This uses the [Haversine formula](http://en.wikipedia.org/wiki/Haversine_formula) to account for global curvature.\n *\n * @name destination\n * @param {Coord} origin starting point\n * @param {number} distance distance from the origin point\n * @param {number} bearing ranging from -180 to 180\n * @param {Object} [options={}] Optional parameters\n * @param {string} [options.units='kilometers'] miles, kilometers, degrees, or radians\n * @param {Object} [options.properties={}] Translate properties to Point\n * @returns {Feature<Point>} destination point\n * @example\n * var point = turf.point([-75.343, 39.984]);\n * var distance = 50;\n * var bearing = 90;\n * var options = {units: 'miles'};\n *\n * var destination = turf.destination(point, distance, bearing, options);\n *\n * //addToMap\n * var addToMap = [point, destination]\n * destination.properties['marker-color'] = '#f00';\n * point.properties['marker-color'] = '#0f0';\n */\nfunction destination(origin, distance, bearing, options) {\n    if (options === void 0) { options = {}; }\n    // Handle input\n    var coordinates1 = invariant_1.getCoord(origin);\n    var longitude1 = helpers_1.degreesToRadians(coordinates1[0]);\n    var latitude1 = helpers_1.degreesToRadians(coordinates1[1]);\n    var bearingRad = helpers_1.degreesToRadians(bearing);\n    var radians = helpers_1.lengthToRadians(distance, options.units);\n    // Main\n    var latitude2 = Math.asin(Math.sin(latitude1) * Math.cos(radians) +\n        Math.cos(latitude1) * Math.sin(radians) * Math.cos(bearingRad));\n    var longitude2 = longitude1 + Math.atan2(Math.sin(bearingRad) * Math.sin(radians) * Math.cos(latitude1), Math.cos(radians) - Math.sin(latitude1) * Math.sin(latitude2));\n    var lng = helpers_1.radiansToDegrees(longitude2);\n    var lat = helpers_1.radiansToDegrees(latitude2);\n    return helpers_1.point([lng, lat], options.properties);\n}\nexports.default = destination;\n"],"sourceRoot":""}